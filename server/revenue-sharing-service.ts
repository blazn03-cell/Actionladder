import { calculateCommission, COMMISSION_CONFIG } from \"./pricing-service\";\nimport { createStripeDescription } from \"./sanitize\";\n\n// Revenue sharing automation for operators\n\nexport interface RevenueCalculation {\n  totalAmount: number;\n  actionLadderShare: number;\n  operatorShare: number;\n  bonusFundShare: number;\n  prizePoolShare: number;\n  commissionRate: number;\n}\n\nexport interface OperatorEarnings {\n  operatorId: string;\n  periodStart: Date;\n  periodEnd: Date;\n  matchCommissions: number;\n  membershipCommissions: number;\n  escrowCommissions: number;\n  bonusEarnings: number;\n  totalEarnings: number;\n}\n\nexport interface PayoutSchedule {\n  operatorId: string;\n  frequency: 'daily' | 'weekly' | 'monthly';\n  minimumThreshold: number;\n  autoPayoutEnabled: boolean;\n  nextPayoutDate: Date;\n}\n\n/**\n * Calculate revenue split for a transaction\n */\nexport function calculateRevenueSplit(\n  amount: number,\n  transactionType: string,\n  membershipTier: string = \"none\",\n  operatorTier: string = \"basic_hall\"\n): RevenueCalculation {\n  const commission = calculateCommission(amount, membershipTier);\n  \n  // Adjust operator share based on operator tier\n  let operatorSharePercent = COMMISSION_CONFIG.SPLIT_PERCENTAGES.OPERATOR;\n  \n  // Operator tier bonuses\n  if (operatorTier === \"elite_operator\") {\n    operatorSharePercent += 5; // +5% for elite operators\n  } else if (operatorTier === \"franchise\") {\n    operatorSharePercent += 10; // +10% for franchise operators\n  }\n  \n  // Recalculate shares with operator bonus\n  const totalSharePercent = 100;\n  const actionLadderPercent = Math.max(30, 100 - operatorSharePercent - COMMISSION_CONFIG.SPLIT_PERCENTAGES.BONUS_FUND);\n  \n  const operatorShare = Math.floor(commission.roundedCommission * (operatorSharePercent / 100));\n  const bonusFundShare = Math.floor(commission.roundedCommission * (COMMISSION_CONFIG.SPLIT_PERCENTAGES.BONUS_FUND / 100));\n  const actionLadderShare = commission.roundedCommission - operatorShare - bonusFundShare;\n  \n  return {\n    totalAmount: amount,\n    actionLadderShare,\n    operatorShare,\n    bonusFundShare,\n    prizePoolShare: commission.prizePool,\n    commissionRate: commission.commissionRate,\n  };\n}\n\n/**\n * Calculate operator earnings for a period\n */\nexport function calculatePeriodEarnings(\n  transactions: Array<{\n    amount: number;\n    type: string;\n    membershipTier?: string;\n    operatorTier?: string;\n    timestamp: Date;\n  }>,\n  periodStart: Date,\n  periodEnd: Date\n): OperatorEarnings {\n  const periodTransactions = transactions.filter(\n    tx => tx.timestamp >= periodStart && tx.timestamp <= periodEnd\n  );\n  \n  let matchCommissions = 0;\n  let membershipCommissions = 0;\n  let escrowCommissions = 0;\n  let bonusEarnings = 0;\n  \n  for (const tx of periodTransactions) {\n    const split = calculateRevenueSplit(\n      tx.amount,\n      tx.type,\n      tx.membershipTier,\n      tx.operatorTier\n    );\n    \n    switch (tx.type) {\n      case \"challenge_fee\":\n      case \"match_entry\":\n        matchCommissions += split.operatorShare;\n        break;\n      case \"membership\":\n        membershipCommissions += split.operatorShare;\n        break;\n      case \"escrow_fee\":\n      case \"side_pot\":\n        escrowCommissions += split.operatorShare;\n        break;\n      case \"live_stream_bonus\":\n      case \"promo_bonus\":\n        bonusEarnings += split.operatorShare;\n        break;\n    }\n  }\n  \n  return {\n    operatorId: \"\", // To be set by caller\n    periodStart,\n    periodEnd,\n    matchCommissions,\n    membershipCommissions,\n    escrowCommissions,\n    bonusEarnings,\n    totalEarnings: matchCommissions + membershipCommissions + escrowCommissions + bonusEarnings,\n  };\n}\n\n/**\n * Determine payout eligibility and schedule\n */\nexport function calculatePayoutSchedule(\n  currentEarnings: number,\n  frequency: 'daily' | 'weekly' | 'monthly',\n  minimumThreshold: number = 2000, // $20 minimum\n  lastPayoutDate?: Date\n): {\n  eligible: boolean;\n  nextPayoutDate: Date;\n  amount: number;\n  reason: string;\n} {\n  const now = new Date();\n  const meetsMinimum = currentEarnings >= minimumThreshold;\n  \n  if (!meetsMinimum) {\n    return {\n      eligible: false,\n      nextPayoutDate: getNextPayoutDate(now, frequency),\n      amount: 0,\n      reason: `Minimum threshold not met ($${(minimumThreshold/100).toFixed(2)})`,\n    };\n  }\n  \n  const nextScheduledDate = getNextPayoutDate(lastPayoutDate || now, frequency);\n  const timeForPayout = now >= nextScheduledDate;\n  \n  if (!timeForPayout) {\n    return {\n      eligible: false,\n      nextPayoutDate: nextScheduledDate,\n      amount: currentEarnings,\n      reason: `Next payout scheduled for ${nextScheduledDate.toLocaleDateString()}`,\n    };\n  }\n  \n  return {\n    eligible: true,\n    nextPayoutDate: getNextPayoutDate(now, frequency),\n    amount: currentEarnings,\n    reason: \"Ready for payout\",\n  };\n}\n\n/**\n * Generate Stripe transfer metadata for operator payout\n */\nexport function createPayoutMetadata(\n  operatorId: string,\n  periodStart: Date,\n  periodEnd: Date,\n  earnings: OperatorEarnings\n): Record<string, string> {\n  return {\n    operator_id: operatorId,\n    period_start: periodStart.toISOString(),\n    period_end: periodEnd.toISOString(),\n    match_commissions: (earnings.matchCommissions / 100).toFixed(2),\n    membership_commissions: (earnings.membershipCommissions / 100).toFixed(2),\n    escrow_commissions: (earnings.escrowCommissions / 100).toFixed(2),\n    bonus_earnings: (earnings.bonusEarnings / 100).toFixed(2),\n    total_earnings: (earnings.totalEarnings / 100).toFixed(2),\n    payout_type: \"operator_commission\",\n    description: createStripeDescription(`Operator earnings for ${periodStart.toLocaleDateString()} - ${periodEnd.toLocaleDateString()}`),\n  };\n}\n\n/**\n * Calculate live streaming bonus\n */\nexport function calculateStreamingBonus(\n  baseEarnings: number,\n  streamingHours: number,\n  viewerCount: number\n): {\n  bonusAmount: number;\n  bonusType: string;\n  description: string;\n} {\n  let bonus = 0;\n  let bonusType = \"none\";\n  let description = \"No streaming bonus earned\";\n  \n  // Base streaming bonus: $5 per hour of live streaming\n  if (streamingHours > 0) {\n    bonus += streamingHours * 500; // $5 per hour\n    bonusType = \"streaming_hours\";\n    description = `${streamingHours} hours of live streaming`;\n  }\n  \n  // Viewer bonus: $1 per 10 average viewers\n  if (viewerCount >= 10) {\n    const viewerBonus = Math.floor(viewerCount / 10) * 100; // $1 per 10 viewers\n    bonus += viewerBonus;\n    bonusType = streamingHours > 0 ? \"streaming_plus_viewers\" : \"viewer_bonus\";\n    description += viewerCount >= 10 ? ` + ${viewerCount} average viewers` : \"\";\n  }\n  \n  return {\n    bonusAmount: bonus,\n    bonusType,\n    description,\n  };\n}\n\n/**\n * White-label revenue sharing\n */\nexport function calculateWhiteLabelSplit(\n  baseRevenue: number,\n  isWhiteLabel: boolean,\n  operatorTier: string\n): {\n  operatorShare: number;\n  actionLadderShare: number;\n  whiteLabelFee: number;\n} {\n  if (!isWhiteLabel) {\n    // Standard revenue split\n    return {\n      operatorShare: Math.floor(baseRevenue * 0.7), // 70% to operator\n      actionLadderShare: Math.floor(baseRevenue * 0.3), // 30% to Action Ladder\n      whiteLabelFee: 0,\n    };\n  }\n  \n  // White-label operators pay additional fee but keep more revenue\n  const whiteLabelFeeRate = operatorTier === \"franchise\" ? 0.05 : 0.1; // 5% for franchise, 10% for others\n  const whiteLabelFee = Math.floor(baseRevenue * whiteLabelFeeRate);\n  \n  return {\n    operatorShare: Math.floor(baseRevenue * 0.85) - whiteLabelFee, // 85% minus white-label fee\n    actionLadderShare: Math.floor(baseRevenue * 0.15) + whiteLabelFee, // 15% plus white-label fee\n    whiteLabelFee,\n  };\n}\n\n/**\n * Calculate membership commission for operators\n */\nexport function calculateMembershipCommission(\n  membershipPrice: number,\n  membershipTier: string,\n  operatorTier: string\n): {\n  operatorCommission: number;\n  commissionRate: number;\n  description: string;\n} {\n  // Base commission rates for membership referrals\n  const baseRates = {\n    rookie: 0.15, // 15% for rookie memberships\n    basic: 0.20, // 20% for basic memberships\n    pro: 0.25, // 25% for pro memberships\n  };\n  \n  const baseRate = baseRates[membershipTier.toLowerCase() as keyof typeof baseRates] || 0.15;\n  \n  // Operator tier bonuses\n  let bonusRate = 0;\n  if (operatorTier === \"elite_operator\") {\n    bonusRate = 0.05; // +5% for elite\n  } else if (operatorTier === \"franchise\") {\n    bonusRate = 0.10; // +10% for franchise\n  }\n  \n  const totalRate = Math.min(baseRate + bonusRate, 0.35); // Cap at 35%\n  const commission = Math.floor(membershipPrice * totalRate);\n  \n  return {\n    operatorCommission: commission,\n    commissionRate: totalRate,\n    description: `${(totalRate * 100).toFixed(0)}% commission on ${membershipTier} membership`,\n  };\n}\n\n/**\n * Operator performance incentives\n */\nexport function calculatePerformanceBonus(\n  monthlyStats: {\n    newSignups: number;\n    activeMatches: number;\n    streamingHours: number;\n    memberRetention: number; // Percentage\n  }\n): {\n  signupBonus: number;\n  activityBonus: number;\n  streamingBonus: number;\n  retentionBonus: number;\n  totalBonus: number;\n} {\n  // Signup bonus: $10 per new member\n  const signupBonus = monthlyStats.newSignups * 1000; // $10 each\n  \n  // Activity bonus: $1 per match facilitated\n  const activityBonus = monthlyStats.activeMatches * 100; // $1 each\n  \n  // Streaming bonus: $5 per hour\n  const streamingBonus = monthlyStats.streamingHours * 500; // $5 per hour\n  \n  // Retention bonus: $50 if >80% retention, $100 if >90%\n  let retentionBonus = 0;\n  if (monthlyStats.memberRetention >= 90) {\n    retentionBonus = 10000; // $100 for excellent retention\n  } else if (monthlyStats.memberRetention >= 80) {\n    retentionBonus = 5000; // $50 for good retention\n  }\n  \n  return {\n    signupBonus,\n    activityBonus,\n    streamingBonus,\n    retentionBonus,\n    totalBonus: signupBonus + activityBonus + streamingBonus + retentionBonus,\n  };\n}\n\n// Helper function to calculate next payout date\nfunction getNextPayoutDate(lastDate: Date, frequency: 'daily' | 'weekly' | 'monthly'): Date {\n  const next = new Date(lastDate);\n  \n  switch (frequency) {\n    case 'daily':\n      next.setDate(next.getDate() + 1);\n      break;\n    case 'weekly':\n      next.setDate(next.getDate() + 7);\n      break;\n    case 'monthly':\n      next.setMonth(next.getMonth() + 1);\n      break;\n  }\n  \n  return next;\n}