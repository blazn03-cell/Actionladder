import { calculateSuspicionScore, shouldAutoPromote, SUSPICION_THRESHOLDS, PENALTY_LADDER } from \"./pricing-service\";\nimport { sanitizeForDisplay } from \"./sanitize\";\n\n// Anti-sandbagging detection and fair play enforcement service\n\nexport interface PlayerPerformanceMetrics {\n  playerId: string;\n  winStreakVsHigher: number;\n  totalGamesVsHigher: number;\n  breakRunPercent: number;\n  averageBreakRunPercent: number;\n  rackDifferentialAvg: number;\n  suddenRatingDrops: number;\n  operatorFlags: number;\n  peerReports: number;\n  currentTier: string;\n  totalMatches: number;\n}\n\nexport interface SuspicionAnalysis {\n  playerId: string;\n  suspicionScore: number;\n  shouldReview: boolean;\n  shouldLock: boolean;\n  shouldAutoPromote: boolean;\n  triggers: string[];\n  recommendedActions: string[];\n}\n\nexport interface TierAdjustmentResult {\n  fromTier: string;\n  toTier: string;\n  reason: string;\n  triggerMetric: string;\n  triggerValue: number;\n  pastResultsAdjusted: boolean;\n}\n\n/**\n * Analyze player performance for sandbagging indicators\n */\nexport function analyzeSandbagging(metrics: PlayerPerformanceMetrics): SuspicionAnalysis {\n  const suspicionScore = calculateSuspicionScore({\n    winStreakVsHigher: metrics.winStreakVsHigher,\n    breakRunPercent: metrics.breakRunPercent,\n    averageBreakRunPercent: metrics.averageBreakRunPercent,\n    rackDifferentialAvg: metrics.rackDifferentialAvg,\n    suddenRatingDrops: metrics.suddenRatingDrops,\n    operatorFlags: metrics.operatorFlags,\n    peerReports: metrics.peerReports,\n  });\n\n  const shouldReview = suspicionScore >= SUSPICION_THRESHOLDS.REVIEW_TRIGGER;\n  const shouldLock = suspicionScore >= SUSPICION_THRESHOLDS.LOCK_TRIGGER;\n  \n  const promotionCheck = shouldAutoPromote({\n    winsVsHigherTier: metrics.winStreakVsHigher,\n    totalGamesVsHigher: metrics.totalGamesVsHigher,\n    breakRunPercent: metrics.breakRunPercent,\n    rackDifferentialAvg: metrics.rackDifferentialAvg,\n  });\n\n  const triggers: string[] = [];\n  const recommendedActions: string[] = [];\n\n  // Identify specific triggers\n  if (metrics.winStreakVsHigher >= 5) {\n    triggers.push(`${metrics.winStreakVsHigher} win streak vs higher tier`);\n  }\n  \n  if (metrics.breakRunPercent - metrics.averageBreakRunPercent > 20) {\n    triggers.push(`Break-run % ${metrics.breakRunPercent}% (${metrics.breakRunPercent - metrics.averageBreakRunPercent}% above average)`);\n  }\n  \n  if (metrics.rackDifferentialAvg > 3) {\n    triggers.push(`Rack differential average: +${metrics.rackDifferentialAvg}`);\n  }\n  \n  if (metrics.suddenRatingDrops > 0) {\n    triggers.push(`${metrics.suddenRatingDrops} sudden rating drops`);\n  }\n  \n  if (metrics.operatorFlags > 0) {\n    triggers.push(`${metrics.operatorFlags} operator flags`);\n  }\n  \n  if (metrics.peerReports > 0) {\n    triggers.push(`${metrics.peerReports} peer reports`);\n  }\n\n  // Generate recommended actions\n  if (shouldLock) {\n    recommendedActions.push(\"IMMEDIATE: Lock profile for admin review\");\n    recommendedActions.push(\"Provisional tier adjustment pending investigation\");\n  } else if (shouldReview) {\n    recommendedActions.push(\"Schedule admin review within 24 hours\");\n    recommendedActions.push(\"Request additional footage verification\");\n  }\n  \n  if (promotionCheck.shouldPromote) {\n    recommendedActions.push(`Auto-promote: ${promotionCheck.reason}`);\n  }\n  \n  if (metrics.operatorFlags > 0) {\n    recommendedActions.push(\"Contact operator for detailed report\");\n  }\n\n  return {\n    playerId: metrics.playerId,\n    suspicionScore,\n    shouldReview,\n    shouldLock,\n    shouldAutoPromote: promotionCheck.shouldPromote,\n    triggers,\n    recommendedActions,\n  };\n}\n\n/**\n * Calculate dynamic tier adjustment\n */\nexport function calculateTierAdjustment(\n  currentTier: string,\n  metrics: PlayerPerformanceMetrics\n): TierAdjustmentResult | null {\n  const tierLevels = { \"rookie\": 1, \"basic\": 2, \"pro\": 3 };\n  const currentLevel = tierLevels[currentTier.toLowerCase() as keyof typeof tierLevels] || 1;\n  \n  const promotionCheck = shouldAutoPromote({\n    winsVsHigherTier: metrics.winStreakVsHigher,\n    totalGamesVsHigher: metrics.totalGamesVsHigher,\n    breakRunPercent: metrics.breakRunPercent,\n    rackDifferentialAvg: metrics.rackDifferentialAvg,\n  });\n  \n  if (promotionCheck.shouldPromote && currentLevel < 3) {\n    const tierNames = [\"rookie\", \"basic\", \"pro\"];\n    const newTier = tierNames[currentLevel]; // Promote one level\n    \n    return {\n      fromTier: currentTier,\n      toTier: newTier,\n      reason: \"auto_promotion\",\n      triggerMetric: promotionCheck.reason || \"multiple_criteria\",\n      triggerValue: metrics.breakRunPercent,\n      pastResultsAdjusted: true,\n    };\n  }\n  \n  // Check for sandbagging (demotion)\n  const suspicionScore = calculateSuspicionScore({\n    winStreakVsHigher: metrics.winStreakVsHigher,\n    breakRunPercent: metrics.breakRunPercent,\n    averageBreakRunPercent: metrics.averageBreakRunPercent,\n    rackDifferentialAvg: metrics.rackDifferentialAvg,\n    suddenRatingDrops: metrics.suddenRatingDrops,\n    operatorFlags: metrics.operatorFlags,\n    peerReports: metrics.peerReports,\n  });\n  \n  if (suspicionScore >= SUSPICION_THRESHOLDS.LOCK_TRIGGER && currentLevel > 1) {\n    const tierNames = [\"rookie\", \"basic\", \"pro\"];\n    const newTier = tierNames[Math.max(0, currentLevel - 2)]; // Demote for sandbagging\n    \n    return {\n      fromTier: currentTier,\n      toTier: newTier,\n      reason: \"sandbagging_detected\",\n      triggerMetric: \"suspicion_score\",\n      triggerValue: suspicionScore,\n      pastResultsAdjusted: true,\n    };\n  }\n  \n  return null;\n}\n\n/**\n * Apply penalty ladder based on offense count\n */\nexport function applyPenaltyLadder(offenseNumber: number): {\n  penaltyType: string;\n  description: string;\n  severity: string;\n  suspensionDays?: number;\n  publicNotice?: boolean;\n  tierRestriction?: string;\n  creditLoss?: number;\n} {\n  switch (offenseNumber) {\n    case 1:\n      return {\n        penaltyType: PENALTY_LADDER.FIRST_OFFENSE.type,\n        description: PENALTY_LADDER.FIRST_OFFENSE.description,\n        severity: PENALTY_LADDER.FIRST_OFFENSE.severity,\n        creditLoss: 500, // $5 credit loss\n      };\n    \n    case 2:\n      return {\n        penaltyType: PENALTY_LADDER.SECOND_OFFENSE.type,\n        description: PENALTY_LADDER.SECOND_OFFENSE.description,\n        severity: PENALTY_LADDER.SECOND_OFFENSE.severity,\n        suspensionDays: PENALTY_LADDER.SECOND_OFFENSE.suspensionDays,\n        publicNotice: PENALTY_LADDER.SECOND_OFFENSE.publicNotice,\n        creditLoss: 1000, // $10 credit loss\n      };\n    \n    default: // 3rd offense and beyond\n      return {\n        penaltyType: PENALTY_LADDER.THIRD_OFFENSE.type,\n        description: PENALTY_LADDER.THIRD_OFFENSE.description,\n        severity: PENALTY_LADDER.THIRD_OFFENSE.severity,\n        tierRestriction: PENALTY_LADDER.THIRD_OFFENSE.tierRestriction,\n        publicNotice: PENALTY_LADDER.THIRD_OFFENSE.publicNotice,\n        creditLoss: 2000, // $20 credit loss\n      };\n  }\n}\n\n/**\n * Generate fair play notice for public posting\n */\nexport function generateFairPlayNotice(\n  playerName: string,\n  violationType: string,\n  penaltyType: string,\n  offenseNumber: number\n): string {\n  const notice = `Fair Play Notice: Player ${playerName} has received a ${penaltyType} penalty for ${violationType}. This is their ${getOrdinal(offenseNumber)} offense. Action Ladder maintains competitive integrity through fair play enforcement.`;\n  \n  return sanitizeForDisplay(notice);\n}\n\n/**\n * Verified placement requirements for new players\n */\nexport function getPlacementRequirements(hasRating: boolean): {\n  requiredMatches: number;\n  requiresStreaming: boolean;\n  requiresOperatorVerification: boolean;\n  description: string;\n} {\n  if (hasRating) {\n    return {\n      requiredMatches: 0,\n      requiresStreaming: false,\n      requiresOperatorVerification: true,\n      description: \"FargoRate ID verified - requires operator confirmation\",\n    };\n  }\n  \n  return {\n    requiredMatches: 5,\n    requiresStreaming: true,\n    requiresOperatorVerification: true,\n    description: \"5 placement matches required (streamed or operator-verified)\",\n  };\n}\n\n/**\n * Footage requirement checker\n */\nexport function validateFootageRequirement(\n  matchId: string,\n  footageUrl?: string,\n  operatorVerified: boolean = false,\n  hoursAfterMatch: number = 0\n): {\n  valid: boolean;\n  requirement: string;\n  deadline: string;\n  violation?: string;\n} {\n  const hasFootage = Boolean(footageUrl);\n  const withinDeadline = hoursAfterMatch <= 24;\n  \n  if (operatorVerified) {\n    return {\n      valid: true,\n      requirement: \"Operator verified\",\n      deadline: \"N/A - operator present\",\n    };\n  }\n  \n  if (!hasFootage) {\n    return {\n      valid: false,\n      requirement: \"Upload match footage\",\n      deadline: \"24 hours after match\",\n      violation: \"No footage uploaded\",\n    };\n  }\n  \n  if (!withinDeadline) {\n    return {\n      valid: false,\n      requirement: \"Upload within 24 hours\",\n      deadline: \"24 hours after match\",\n      violation: `Late upload (${hoursAfterMatch} hours)`,\n    };\n  }\n  \n  return {\n    valid: true,\n    requirement: \"Footage uploaded\",\n    deadline: \"Met - uploaded within 24 hours\",\n  };\n}\n\n/**\n * Play-up incentive calculator\n */\nexport function calculatePlayUpBonus(\n  playerTier: string,\n  opponentTier: string,\n  upset: boolean = false\n): {\n  bonusAmount: number;\n  bonusType: string;\n  badgeEarned?: string;\n  description: string;\n} | null {\n  const tierLevels = { \"rookie\": 1, \"basic\": 2, \"pro\": 3 };\n  const playerLevel = tierLevels[playerTier.toLowerCase() as keyof typeof tierLevels] || 1;\n  const opponentLevel = tierLevels[opponentTier.toLowerCase() as keyof typeof tierLevels] || 1;\n  \n  if (opponentLevel > playerLevel) {\n    const tierDifference = opponentLevel - playerLevel;\n    const baseBonus = tierDifference * 500; // $5 per tier difference\n    \n    if (upset && tierDifference >= 2) {\n      return {\n        bonusAmount: baseBonus * 2, // Double bonus for major upsets\n        bonusType: \"major_upset\",\n        badgeEarned: \"upset_king\",\n        description: `Major upset! Defeated ${opponentTier} tier opponent as ${playerTier}`,\n      };\n    }\n    \n    return {\n      bonusAmount: baseBonus,\n      bonusType: \"play_up\",\n      badgeEarned: tierDifference >= 2 ? \"giant_killer\" : \"play_up_warrior\",\n      description: `Play-up victory against ${opponentTier} tier opponent`,\n    };\n  }\n  \n  return null;\n}\n\n/**\n * Fast-track graduation checker for rookies\n */\nexport function checkFastTrackEligibility(\n  rookieWins: number,\n  winStreak: number,\n  versifiedMatches: number\n): {\n  eligible: boolean;\n  requirement: string;\n  progress: string;\n} {\n  const FAST_TRACK_WINS = 10;\n  \n  if (rookieWins >= FAST_TRACK_WINS && versifiedMatches >= FAST_TRACK_WINS) {\n    return {\n      eligible: true,\n      requirement: \"10 verified wins vs rookie peers\",\n      progress: `Complete! ${rookieWins}/${FAST_TRACK_WINS} wins`,\n    };\n  }\n  \n  return {\n    eligible: false,\n    requirement: \"10 verified wins vs rookie peers\",\n    progress: `${rookieWins}/${FAST_TRACK_WINS} wins (${versifiedMatches} verified)`,\n  };\n}\n\n// Helper function for ordinal numbers\nfunction getOrdinal(n: number): string {\n  const s = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = n % 100;\n  return n + (s[(v - 20) % 10] || s[v] || s[0]);\n}