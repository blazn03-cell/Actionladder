import { sanitizeForDisplay } from \"./sanitize\";\n\n// Pricing tier configurations based on monetization plan\nexport const MEMBERSHIP_TIERS = {\n  ROOKIE: {\n    name: \"Rookie\",\n    price: 2000, // $20 in cents\n    commissionRate: 1000, // 10% in basis points\n    perks: [\"training_credits\", \"access_to_matches\"],\n    description: \"Perfect for beginners learning the game\",\n  },\n  BASIC: {\n    name: \"Basic\", \n    price: 2500, // $25 in cents\n    commissionRate: 800, // 8% in basis points\n    perks: [\"tournament_eligibility\", \"reduced_commission\"],\n    description: \"Competitive play with tournament access\",\n  },\n  PRO: {\n    name: \"Pro\",\n    price: 6000, // $60 in cents\n    commissionRate: 500, // 5% in basis points\n    perks: [\"free_tournaments\", \"lowest_commission\", \"prestige_badge\", \"priority_support\"],\n    description: \"Premium tier with maximum savings\",\n  },\n} as const;\n\n// Commission structure: \"cheaper than leagues\" with 5-10% + round-up\nexport const COMMISSION_CONFIG = {\n  BASE_RATE: 1000, // 10% in basis points\n  MEMBER_RATE: 500, // 5% for members in basis points\n  ROOKIE_RATE: 1000, // 10% for rookie tier\n  BASIC_RATE: 800, // 8% for basic tier\n  PRO_RATE: 500, // 5% for pro tier\n  ROUND_UP_ENABLED: true, // Round up to nearest $1 for extra profit\n  SPLIT_PERCENTAGES: {\n    ACTION_LADDER: 50, // 50% of commission goes to platform\n    OPERATOR: 30, // 30% goes to operator\n    BONUS_FUND: 20, // 20% goes to league bonus fund\n  },\n} as const;\n\n// Anti-sandbagging thresholds\nexport const SUSPICION_THRESHOLDS = {\n  REVIEW_TRIGGER: 7.0, // Auto-review at 7+ points\n  LOCK_TRIGGER: 9.0, // Auto-lock at 9+ points\n  MAX_SCORE: 10.0,\n  WEIGHTS: {\n    WIN_STREAK_VS_HIGHER: 2.0, // High weight for beating higher tiers\n    BREAK_RUN_OUTLIER: 1.5, // Break and run % outlier\n    RACK_DIFFERENTIAL: 1.0, // Average rack differential\n    RATING_DROPS: 2.5, // Sudden rating drops before events\n    OPERATOR_FLAGS: 3.0, // Operator reports\n    PEER_REPORTS: 1.5, // Peer reports\n  },\n} as const;\n\n// Fair play penalty ladder\nexport const PENALTY_LADDER = {\n  FIRST_OFFENSE: {\n    type: \"tier_correction\",\n    description: \"Tier correction + loss of credits for mis-tiered matches\",\n    severity: \"minor\",\n  },\n  SECOND_OFFENSE: {\n    type: \"suspension\",\n    description: \"30-day suspension + public Fair Play Notice\",\n    severity: \"major\",\n    suspensionDays: 30,\n    publicNotice: true,\n  },\n  THIRD_OFFENSE: {\n    type: \"pro_only\",\n    description: \"Permanent lower-tier ban (Pro-only eligibility)\",\n    severity: \"severe\",\n    tierRestriction: \"pro_only\",\n    publicNotice: true,\n  },\n} as const;\n\n/**\n * Calculate commission with round-up profit margin\n * Example: $100 challenge â†’ $90 pot + $10 fee\n * Split: $5 Action Ladder + $3 operator + $2 bonus fund\n */\nexport function calculateCommission(amount: number, membershipTier: string = \"none\"): {\n  originalAmount: number;\n  commissionRate: number;\n  calculatedCommission: number;\n  roundedCommission: number;\n  actionLadderShare: number;\n  operatorShare: number;\n  bonusFundShare: number;\n  prizePool: number;\n} {\n  const commissionRate = getCommissionRate(membershipTier);\n  const calculatedCommission = Math.ceil(amount * (commissionRate / 10000));\n  \n  // Round up to nearest $1 for extra profit\n  const roundedCommission = COMMISSION_CONFIG.ROUND_UP_ENABLED \n    ? Math.ceil(calculatedCommission / 100) * 100\n    : calculatedCommission;\n  \n  // Split commission according to percentages\n  const actionLadderShare = Math.floor(roundedCommission * (COMMISSION_CONFIG.SPLIT_PERCENTAGES.ACTION_LADDER / 100));\n  const operatorShare = Math.floor(roundedCommission * (COMMISSION_CONFIG.SPLIT_PERCENTAGES.OPERATOR / 100));\n  const bonusFundShare = Math.floor(roundedCommission * (COMMISSION_CONFIG.SPLIT_PERCENTAGES.BONUS_FUND / 100));\n  \n  const prizePool = amount - roundedCommission;\n  \n  return {\n    originalAmount: amount,\n    commissionRate,\n    calculatedCommission,\n    roundedCommission,\n    actionLadderShare,\n    operatorShare,\n    bonusFundShare,\n    prizePool,\n  };\n}\n\n/**\n * Get commission rate based on membership tier\n */\nexport function getCommissionRate(membershipTier: string): number {\n  switch (membershipTier.toLowerCase()) {\n    case \"rookie\":\n      return COMMISSION_CONFIG.ROOKIE_RATE;\n    case \"basic\":\n      return COMMISSION_CONFIG.BASIC_RATE;\n    case \"pro\":\n      return COMMISSION_CONFIG.PRO_RATE;\n    default:\n      return COMMISSION_CONFIG.BASE_RATE; // Non-members pay full rate\n  }\n}\n\n/**\n * Calculate membership savings vs APA/BCA costs\n */\nexport function calculateSavings(tier: string, monthlyMatches: number): {\n  actionLadderCost: number;\n  competitorCost: number;\n  monthlySavings: number;\n  annualSavings: number;\n} {\n  const tierConfig = MEMBERSHIP_TIERS[tier.toUpperCase() as keyof typeof MEMBERSHIP_TIERS];\n  if (!tierConfig) {\n    throw new Error(\"Invalid membership tier\");\n  }\n  \n  // Estimate competitor costs (APA/BCA typically $30-40/month + higher fees)\n  const competitorMonthlyCost = 3500; // $35/month\n  const competitorMatchFee = 1500; // $15/match\n  \n  const actionLadderMonthlyCost = tierConfig.price;\n  const actionLadderMatchFee = 1000; // $10/match average with lower commission\n  \n  const actionLadderTotal = actionLadderMonthlyCost + (actionLadderMatchFee * monthlyMatches);\n  const competitorTotal = competitorMonthlyCost + (competitorMatchFee * monthlyMatches);\n  \n  const monthlySavings = competitorTotal - actionLadderTotal;\n  const annualSavings = monthlySavings * 12;\n  \n  return {\n    actionLadderCost: actionLadderTotal,\n    competitorCost: competitorTotal,\n    monthlySavings,\n    annualSavings,\n  };\n}\n\n/**\n * Calculate suspicion score based on player performance metrics\n */\nexport function calculateSuspicionScore(metrics: {\n  winStreakVsHigher: number;\n  breakRunPercent: number;\n  averageBreakRunPercent: number;\n  rackDifferentialAvg: number;\n  suddenRatingDrops: number;\n  operatorFlags: number;\n  peerReports: number;\n}): number {\n  let score = 0;\n  \n  // Win streak against higher tier opponents (max 5 matches = 2.0 points)\n  if (metrics.winStreakVsHigher >= 5) {\n    score += SUSPICION_THRESHOLDS.WEIGHTS.WIN_STREAK_VS_HIGHER;\n  }\n  \n  // Break and run percentage outlier (>95th percentile = 1.5 points)\n  const breakRunOutlier = metrics.breakRunPercent - metrics.averageBreakRunPercent;\n  if (breakRunOutlier > 20) { // 20% above average\n    score += SUSPICION_THRESHOLDS.WEIGHTS.BREAK_RUN_OUTLIER;\n  }\n  \n  // Rack differential average (>+3 = 1.0 point)\n  if (metrics.rackDifferentialAvg > 3) {\n    score += SUSPICION_THRESHOLDS.WEIGHTS.RACK_DIFFERENTIAL;\n  }\n  \n  // Sudden rating drops (each drop = 2.5 points)\n  score += metrics.suddenRatingDrops * SUSPICION_THRESHOLDS.WEIGHTS.RATING_DROPS;\n  \n  // Operator flags (each flag = 3.0 points)\n  score += metrics.operatorFlags * SUSPICION_THRESHOLDS.WEIGHTS.OPERATOR_FLAGS;\n  \n  // Peer reports (each report = 1.5 points)\n  score += metrics.peerReports * SUSPICION_THRESHOLDS.WEIGHTS.PEER_REPORTS;\n  \n  return Math.min(score, SUSPICION_THRESHOLDS.MAX_SCORE);\n}\n\n/**\n * Determine if auto-tier adjustment is needed\n */\nexport function shouldAutoPromote(metrics: {\n  winsVsHigherTier: number;\n  totalGamesVsHigher: number;\n  breakRunPercent: number;\n  rackDifferentialAvg: number;\n}): { shouldPromote: boolean; reason?: string } {\n  // Auto-promote conditions from monetization plan:\n  // - Win 5/7 vs higher-tier opponents\n  // - Break-and-run % > bracket 95th percentile\n  // - Rack differential avg > +3 across last 10 matches\n  \n  if (metrics.winsVsHigherTier >= 5 && metrics.totalGamesVsHigher >= 7) {\n    return { shouldPromote: true, reason: \"Won 5+ of 7+ games vs higher tier\" };\n  }\n  \n  if (metrics.breakRunPercent > 35) { // 35% is roughly 95th percentile\n    return { shouldPromote: true, reason: \"Break-and-run % exceeds 95th percentile\" };\n  }\n  \n  if (metrics.rackDifferentialAvg > 3) {\n    return { shouldPromote: true, reason: \"Rack differential average >+3\" };\n  }\n  \n  return { shouldPromote: false };\n}\n\n/**\n * Generate Stripe-safe challenge description\n */\nexport function createChallengeDescription(challengeType: string, amount: number, playerCount: number): string {\n  const description = `${challengeType} tournament entry for ${playerCount} competitors at $${(amount/100).toFixed(2)} entry fee`;\n  return sanitizeForDisplay(description);\n}\n\n/**\n * Calculate no-show penalty based on offense count\n */\nexport function calculateNoShowPenalty(offenseCount: number): {\n  penaltyType: string;\n  suspensionDays: number;\n  description: string;\n} {\n  if (offenseCount === 1) {\n    return {\n      penaltyType: \"warning\",\n      suspensionDays: 0,\n      description: \"First offense: Warning issued\",\n    };\n  } else if (offenseCount === 2) {\n    return {\n      penaltyType: \"suspension\",\n      suspensionDays: 30,\n      description: \"Second offense: 30-day suspension\",\n    };\n  } else {\n    return {\n      penaltyType: \"extended_suspension\",\n      suspensionDays: 90,\n      description: \"Third+ offense: 90-day suspension\",\n    };\n  }\n}\n\n/**\n * Generate positive incentive for playing up tiers\n */\nexport function generatePlayUpIncentive(opponentTier: string, playerTier: string): {\n  bonusAmount: number;\n  title: string;\n  description: string;\n  badgeEarned?: string;\n} | null {\n  const tierLevels = { rookie: 1, basic: 2, pro: 3 };\n  const playerLevel = tierLevels[playerTier.toLowerCase() as keyof typeof tierLevels] || 1;\n  const opponentLevel = tierLevels[opponentTier.toLowerCase() as keyof typeof tierLevels] || 1;\n  \n  if (opponentLevel > playerLevel) {\n    const bonus = (opponentLevel - playerLevel) * 500; // $5 per tier difference\n    return {\n      bonusAmount: bonus,\n      title: \"Play-Up Victory!\",\n      description: `Defeated ${opponentTier} tier opponent - bonus earned!`,\n      badgeEarned: \"upset_king\",\n    };\n  }\n  \n  return null;\n}