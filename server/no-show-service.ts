import { calculateNoShowPenalty } from \"./pricing-service\";\nimport { createStripeDescription } from \"./sanitize\";\n\n// No-show prevention and penalty tracking service\n\nexport interface ChallengeHoldConfig {\n  challengeId: string;\n  playerId: string;\n  holdAmount: number;\n  holdType: 'deposit' | 'challenge_fee' | 'penalty';\n  expiresAt: Date;\n}\n\nexport interface NoShowRecord {\n  playerId: string;\n  challengeId: string;\n  scheduledTime: Date;\n  checkInDeadline: Date;\n  actualCheckIn?: Date;\n  noShowConfirmed: boolean;\n  penaltyApplied: boolean;\n  penaltyAmount: number;\n}\n\nexport interface AttendanceVerification {\n  playerId: string;\n  challengeId: string;\n  checkInTime: Date;\n  verificationMethod: 'qr_code' | 'operator_confirm' | 'opponent_confirm';\n  location: string;\n  verified: boolean;\n}\n\n/**\n * Create challenge hold for no-show prevention\n */\nexport function createChallengeHold(\n  challengeId: string,\n  playerId: string,\n  challengeFee: number,\n  depositRequired: boolean = true\n): ChallengeHoldConfig {\n  // Hold either the full challenge fee or a deposit (typically $10-20)\n  const holdAmount = depositRequired ? Math.min(challengeFee, 2000) : challengeFee; // Max $20 deposit\n  const expiresAt = new Date();\n  expiresAt.setHours(expiresAt.getHours() + 48); // 48-hour hold window\n  \n  return {\n    challengeId,\n    playerId,\n    holdAmount,\n    holdType: depositRequired ? 'deposit' : 'challenge_fee',\n    expiresAt,\n  };\n}\n\n/**\n * Calculate check-in deadline with grace period\n */\nexport function calculateCheckInDeadline(\n  scheduledTime: Date,\n  gracePeriodMinutes: number = 10\n): Date {\n  const deadline = new Date(scheduledTime);\n  deadline.setMinutes(deadline.getMinutes() + gracePeriodMinutes);\n  return deadline;\n}\n\n/**\n * Verify player attendance\n */\nexport function verifyAttendance(\n  playerId: string,\n  challengeId: string,\n  checkInMethod: 'qr_code' | 'operator_confirm' | 'opponent_confirm',\n  location: string\n): AttendanceVerification {\n  const checkInTime = new Date();\n  \n  return {\n    playerId,\n    challengeId,\n    checkInTime,\n    verificationMethod: checkInMethod,\n    location,\n    verified: true, // Would validate QR codes, etc. in real implementation\n  };\n}\n\n/**\n * Process no-show and apply penalties\n */\nexport function processNoShow(\n  playerId: string,\n  challengeId: string,\n  scheduledTime: Date,\n  currentOffenseCount: number,\n  holdAmount: number\n): {\n  noShowRecord: NoShowRecord;\n  penalty: {\n    type: string;\n    suspensionDays: number;\n    description: string;\n  };\n  holdAction: 'forfeit' | 'refund';\n  opponentCompensation: number;\n} {\n  const checkInDeadline = calculateCheckInDeadline(scheduledTime);\n  const penalty = calculateNoShowPenalty(currentOffenseCount + 1);\n  \n  const noShowRecord: NoShowRecord = {\n    playerId,\n    challengeId,\n    scheduledTime,\n    checkInDeadline,\n    noShowConfirmed: true,\n    penaltyApplied: true,\n    penaltyAmount: holdAmount,\n  };\n  \n  // Opponent gets compensation from forfeited hold\n  const opponentCompensation = Math.floor(holdAmount * 0.8); // 80% to opponent, 20% to platform\n  \n  return {\n    noShowRecord,\n    penalty: {\n      type: penalty.penaltyType,\n      suspensionDays: penalty.suspensionDays,\n      description: penalty.description,\n    },\n    holdAction: 'forfeit',\n    opponentCompensation,\n  };\n}\n\n/**\n * Handle successful attendance and release holds\n */\nexport function processSuccessfulAttendance(\n  playerId: string,\n  challengeId: string,\n  holdAmount: number,\n  attendanceVerification: AttendanceVerification\n): {\n  holdAction: 'release' | 'convert_to_fee';\n  refundAmount: number;\n  message: string;\n} {\n  if (!attendanceVerification.verified) {\n    throw new Error(\"Attendance not verified\");\n  }\n  \n  // If this was a deposit hold, refund it. If it was the full fee, convert to payment\n  const isDepositHold = holdAmount <= 2000; // $20 or less indicates deposit\n  \n  if (isDepositHold) {\n    return {\n      holdAction: 'release',\n      refundAmount: holdAmount,\n      message: \"Attendance verified - deposit refunded\",\n    };\n  } else {\n    return {\n      holdAction: 'convert_to_fee',\n      refundAmount: 0,\n      message: \"Attendance verified - challenge fee processed\",\n    };\n  }\n}\n\n/**\n * Calculate cancellation fees based on timing\n */\nexport function calculateCancellationFee(\n  challengeFee: number,\n  hoursBeforeMatch: number,\n  playerMembershipTier: string = \"none\"\n): {\n  cancellationFee: number;\n  refundAmount: number;\n  freeReschedule: boolean;\n  description: string;\n} {\n  // Free reschedule if >24 hours notice\n  if (hoursBeforeMatch >= 24) {\n    return {\n      cancellationFee: 0,\n      refundAmount: challengeFee,\n      freeReschedule: true,\n      description: \"Free cancellation - 24+ hours notice\",\n    };\n  }\n  \n  // Pro members get better cancellation terms\n  const memberBonus = playerMembershipTier === \"pro\" ? 12 : 0; // Pro gets 12 extra hours\n  const effectiveHours = hoursBeforeMatch + memberBonus;\n  \n  if (effectiveHours >= 24) {\n    return {\n      cancellationFee: 0,\n      refundAmount: challengeFee,\n      freeReschedule: true,\n      description: \"Free cancellation - Pro member benefit\",\n    };\n  }\n  \n  // Late cancellation fee: $5-15 based on timing\n  let cancellationFee = 500; // $5 base\n  if (hoursBeforeMatch < 4) {\n    cancellationFee = 1500; // $15 for <4 hours\n  } else if (hoursBeforeMatch < 12) {\n    cancellationFee = 1000; // $10 for <12 hours\n  }\n  \n  const refundAmount = Math.max(0, challengeFee - cancellationFee);\n  \n  return {\n    cancellationFee,\n    refundAmount,\n    freeReschedule: false,\n    description: `Late cancellation fee: $${(cancellationFee/100).toFixed(2)} (${hoursBeforeMatch}h notice)`,\n  };\n}\n\n/**\n * Generate QR code data for check-in\n */\nexport function generateCheckInQR(\n  challengeId: string,\n  playerId: string,\n  venueId: string,\n  expiresAt: Date\n): {\n  qrData: string;\n  qrUrl: string;\n  expiresAt: Date;\n  instructions: string;\n} {\n  const qrData = JSON.stringify({\n    type: 'challenge_checkin',\n    challengeId,\n    playerId,\n    venueId,\n    expiresAt: expiresAt.toISOString(),\n    timestamp: new Date().toISOString(),\n  });\n  \n  // In real implementation, this would generate an actual QR code image\n  const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(qrData)}`;\n  \n  return {\n    qrData,\n    qrUrl,\n    expiresAt,\n    instructions: \"Scan this QR code at the venue to confirm your attendance. Code expires 30 minutes after match time.\",\n  };\n}\n\n/**\n * Validate QR code check-in\n */\nexport function validateQRCheckIn(\n  qrData: string,\n  venueId: string,\n  currentTime: Date = new Date()\n): {\n  valid: boolean;\n  challengeId?: string;\n  playerId?: string;\n  error?: string;\n} {\n  try {\n    const data = JSON.parse(qrData);\n    \n    if (data.type !== 'challenge_checkin') {\n      return { valid: false, error: \"Invalid QR code type\" };\n    }\n    \n    if (data.venueId !== venueId) {\n      return { valid: false, error: \"QR code not valid for this venue\" };\n    }\n    \n    const expiresAt = new Date(data.expiresAt);\n    if (currentTime > expiresAt) {\n      return { valid: false, error: \"QR code has expired\" };\n    }\n    \n    return {\n      valid: true,\n      challengeId: data.challengeId,\n      playerId: data.playerId,\n    };\n  } catch (error) {\n    return { valid: false, error: \"Invalid QR code format\" };\n  }\n}\n\n/**\n * Calculate repeat offender escalation\n */\nexport function calculateRepeatOffenderPenalty(\n  noShowHistory: NoShowRecord[],\n  timeWindowDays: number = 90\n): {\n  offenseCount: number;\n  escalatedPenalty: boolean;\n  suspensionDays: number;\n  permanentRestrictions: string[];\n} {\n  const cutoffDate = new Date();\n  cutoffDate.setDate(cutoffDate.getDate() - timeWindowDays);\n  \n  const recentNoShows = noShowHistory.filter(\n    record => new Date(record.scheduledTime) >= cutoffDate\n  );\n  \n  const offenseCount = recentNoShows.length;\n  let suspensionDays = 0;\n  const restrictions: string[] = [];\n  \n  if (offenseCount >= 3) {\n    suspensionDays = 90; // 3-month suspension\n    restrictions.push(\"pro_tier_required\"); // Can only play with Pro membership\n    restrictions.push(\"mandatory_deposits\"); // Must pay deposits for all matches\n  } else if (offenseCount >= 2) {\n    suspensionDays = 30; // 1-month suspension\n    restrictions.push(\"mandatory_deposits\");\n  }\n  \n  return {\n    offenseCount,\n    escalatedPenalty: offenseCount >= 2,\n    suspensionDays,\n    permanentRestrictions: restrictions,\n  };\n}\n\n/**\n * Generate attendance report for operators\n */\nexport function generateAttendanceReport(\n  venueId: string,\n  dateRange: { start: Date; end: Date },\n  attendanceRecords: AttendanceVerification[],\n  noShowRecords: NoShowRecord[]\n): {\n  totalScheduled: number;\n  totalAttended: number;\n  totalNoShows: number;\n  attendanceRate: number;\n  noShowRate: number;\n  topNoShowPlayers: { playerId: string; count: number }[];\n  peakHours: { hour: number; rate: number }[];\n} {\n  const totalScheduled = attendanceRecords.length + noShowRecords.length;\n  const totalAttended = attendanceRecords.length;\n  const totalNoShows = noShowRecords.length;\n  \n  const attendanceRate = totalScheduled > 0 ? (totalAttended / totalScheduled) * 100 : 0;\n  const noShowRate = totalScheduled > 0 ? (totalNoShows / totalScheduled) * 100 : 0;\n  \n  // Calculate repeat offenders\n  const noShowCounts = new Map<string, number>();\n  noShowRecords.forEach(record => {\n    const count = noShowCounts.get(record.playerId) || 0;\n    noShowCounts.set(record.playerId, count + 1);\n  });\n  \n  const topNoShowPlayers = Array.from(noShowCounts.entries())\n    .map(([playerId, count]) => ({ playerId, count }))\n    .sort((a, b) => b.count - a.count)\n    .slice(0, 5);\n  \n  // Calculate peak hours (simplified)\n  const hourCounts = new Map<number, { total: number; attended: number }>();\n  [...attendanceRecords, ...noShowRecords].forEach(record => {\n    const hour = 'checkInTime' in record \n      ? record.checkInTime.getHours() \n      : record.scheduledTime.getHours();\n    const current = hourCounts.get(hour) || { total: 0, attended: 0 };\n    current.total++;\n    if ('checkInTime' in record) current.attended++;\n    hourCounts.set(hour, current);\n  });\n  \n  const peakHours = Array.from(hourCounts.entries())\n    .map(([hour, data]) => ({ hour, rate: data.total > 0 ? (data.attended / data.total) * 100 : 0 }))\n    .sort((a, b) => b.rate - a.rate);\n  \n  return {\n    totalScheduled,\n    totalAttended,\n    totalNoShows,\n    attendanceRate,\n    noShowRate,\n    topNoShowPlayers,\n    peakHours,\n  };\n}\n\n/**\n * Create Stripe payment intent for challenge hold\n */\nexport function createHoldPaymentIntent(\n  challengeId: string,\n  playerId: string,\n  amount: number,\n  description: string\n): {\n  amount: number;\n  currency: string;\n  captureMethod: string;\n  metadata: Record<string, string>;\n  description: string;\n} {\n  return {\n    amount,\n    currency: 'usd',\n    captureMethod: 'manual', // Hold funds without capturing\n    metadata: {\n      challenge_id: challengeId,\n      player_id: playerId,\n      hold_type: 'no_show_prevention',\n      created_at: new Date().toISOString(),\n    },\n    description: createStripeDescription(description),\n  };\n}