Before anything

Verify signature with STRIPE_WEBHOOK_SECRET using stripe.webhooks.constructEvent(rawBody, sig, secret).

Use idempotency: store event.id in a table; skip if already processed.

Process in order: if needed, fetch the full object via API to avoid partial data.

🧠 Key objects you’ll use

checkout.session (mode: subscription or payment)

customer, subscription, invoice, payment_intent, line_items

Price metadata: plan=operator|addon|multihall, tier=small|..., feature=...

Lookup keys (e.g., operator_small_monthly, tourney_20) via line_item.price.lookup_key

✅ Subscribe to these events

checkout.session.completed

customer.subscription.created|updated|deleted

invoice.paid

invoice.payment_failed

customer.subscription.trial_will_end (optional reminder)

(Pay-per-use) payment_intent.succeeded (for one-offs not using Checkout)

(Refunds) charge.refunded (for deposits)

🗺️ Event → Action map
1) checkout.session.completed

When: A user finishes Checkout (new sub, add-on, multihall, or one-time).
Do:

Get the session + line items:

session.customer, session.subscription (if any), session.mode

list line_items → for each item read price.lookup_key and price.metadata

If subscription (Operator / Add-On / Multi-Hall):

Upsert Customer in DB with customerId, email, name.

Upsert Subscription with subscriptionId, status, current_period_end.

For each line item → create/update Entitlements:

plan=operator → set operator tier (tier from metadata or by lookup key).

plan=addon + feature → enable feature flags.

plan=multihall → grant quantity extra halls.

If one-time (Walk-In, Tournament, Deposit):

Record Payment with payment_intent, amount.

Apply business rule:

Walk-In → mark player as “Day Pass active (expires at end of day)”.

Tournament Entry → add entry/credit.

Deposit → mark deposit as “held/paid” (link to booking).

Respond: 200 OK.

2) customer.subscription.created

When: New sub created (can also fire after Checkout).
Do:

Ensure DB has the subscription (idempotent upsert).

Parse items → set operator tier / add-ons / multihall quantity.

Set access active if status in ['active','trialing'].

3) customer.subscription.updated

When: Tier changes, qty changes, add-on toggled, period renewed, payment method changes.
Do:

Update status, current_period_end, cancel_at_period_end.

Diff items:

Operator tier changed → update access level; prorate is handled by Stripe automatically.

Add-on toggled → flip feature flags.

Multihall quantity change → adjust allowed halls.

If status='past_due' → set soft-grace flag (limited access), notify operator.

4) customer.subscription.deleted

When: Canceled or expired.
Do:

Mark operator as inactive at current_period_end (or now if canceled immediately).

Disable add-ons & multihall entitlements.

Send final notice & link to Customer Portal to reactivate.

5) invoice.paid

When: Renewal or first invoice successfully paid.
Do:

Mark billing_ok = true; clear past_due flags.

Extend access until subscription.current_period_end.

For one-offs via Invoice (if used) → deliver entitlement.

6) invoice.payment_failed

When: Card failed on renewal.
Do:

Flag account past_due; start your dunning flow:

Email + in-app banner: “Update payment method” (link to Customer Portal).

If Stripe later retries and succeeds, you’ll get invoice.paid → clear the flag.

If dunning window ends without payment → you’ll receive customer.subscription.updated/deleted. Remove access.

7) customer.subscription.trial_will_end (optional)

When: Trial ending in 3 days (default).
Do: Notify operator to ensure payment method is valid.

8) payment_intent.succeeded (for pay-per-use not through Checkout)

When: One-time payments captured via PaymentIntents API.
Do: Same as one-time in #1:

Create Payment row, apply pass/entry/deposit logic.

9) charge.refunded (deposits)

When: You refund the $30 deposit.
Do: Mark the deposit record refunded and reconcile with booking.

🧱 Suggested DB schema (minimal)

customers: id (pk), stripe_customer_id, email, name, created_at

subscriptions: id (pk), stripe_subscription_id, stripe_customer_id, status, current_period_end, cancel_at_period_end

subscription_items: id, stripe_subscription_item_id, subscription_id, price_lookup_key, quantity, metadata_json

entitlements (denormalized for speed): customer_id, operator_tier, addons_json, multihall_quantity, active_from, active_until

payments: id, stripe_payment_intent_id, type (walkin|tourney|deposit), amount, currency, status, notes

webhook_events: id, stripe_event_id (unique), type, processed_at, payload_json