Pasted-Action-Ladder-Grouped-Navbar-play-teams-tournaments-rankings-media-Ai-promote-operator-types-1757668268711_1757668268711.txt
Action Ladder – Grouped Navbar (play/teams/tournaments/rankings/media & Ai/promote/operator)
· typescript
import React, { useContext } from 'react';
// Usage in app/layout.tsx (Server Component):
// import Navbar from '@/components/Navbar';
// import { getServerUserRole } from '@/lib/auth';
// export default async function RootLayout({ children }: { children: React.ReactNode }) {
//   const role = await getServerUserRole();
//   return (
//     <html lang="en">
//       <body className="min-h-screen bg-zinc-950">
//         <NavbarServer role={role} />
//         {children}
//       </body>
//     </html>
//   );
// }


// Server wrapper so Navbar doesn’t rely on client auth
// export function NavbarServer({ role }: { role: Role }) {
//   return (
//     <div suppressHydrationWarning>
//       {/* if you want client hydration, you can also render <NavbarClient/> and read role via useRole */}
//       <Navbar />
//     </div>
//   );
// }
*/


/**
 * RECIPE B — Custom JWT in Cookie (e.g., /api/login sets a signed JWT with { role })
 * 1) npm i jwt-decode (client) or jose (server)
 * 2) On login, set cookie 'token' with JWT that includes { role }
 * 3) Read cookie and expose role to Navbar
 */
/*
// app/providers/AuthProvider.tsx
'use client';
import Cookies from 'js-cookie';
import jwtDecode from 'jwt-decode';


type JwtPayload = { role?: Role; exp?: number };


export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [role, setRole] = React.useState<Role>('public');
  React.useEffect(() => {
    const token = Cookies.get('token');
    if (token) {
      try {
        const payload = jwtDecode<JwtPayload>(token);
        if (payload?.role) setRole(payload.role);
      } catch {}
    }
  }, []);
  return (
    <AuthContext.Provider value={{ role, setRole }}>{children}</AuthContext.Provider>
  );
}


// Server side (middleware.ts) — optional route guards
// import { NextResponse } from 'next/server';
// import type { NextRequest } from 'next/server';
// import { jwtVerify } from 'jose';
// export async function middleware(req: NextRequest) {
//   const token = req.cookies.get('token')?.value;
//   if (req.nextUrl.pathname.startsWith('/operator')) {
//     if (!token) return NextResponse.redirect(new URL('/join', req.url));
//     try {
//       const { payload } = await jwtVerify(token, new TextEncoder().encode(process.env.JWT_SECRET!));
//       if (!['operator','admin'].includes(String(payload.role))) {
//         return NextResponse.redirect(new URL('/join', req.url));
//       }
//     } catch {
//       return NextResponse.redirect(new URL('/join', req.url));
//     }
//   }
//   return NextResponse.next();
// }
*/


// NOTES:
// - Replace demo AuthProvider with Recipe A or B.
// - Ensure your User model persists role: 'public' | 'operator' | 'admin'.
// - Operator section already hidden via canSee(); server guards add extra protection.
