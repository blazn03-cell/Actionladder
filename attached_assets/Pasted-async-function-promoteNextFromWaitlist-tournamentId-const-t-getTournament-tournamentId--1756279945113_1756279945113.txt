async function promoteNextFromWaitlist(tournamentId) {
  const t = getTournament(tournamentId);
  if (!t) return { ok:false, reason:"tournament_missing" };
  // only if there is a free slot
  const current = countConfirmedEntries(tournamentId);
  if (current >= t.max_slots) return { ok:false, reason:"still_full" };

  const row = nextWaitlistRow(tournamentId);
  if (!row) return { ok:false, reason:"no_waitlist" };

  const status = getMembershipStatus(row.user_id);
  const amountCents = computeTournamentFeeCents(status?.role || "nonmember", t.hall_id || null);

  if (amountCents === 0) {
    // comped promotion — auto convert
    recordTournamentEntry({ tournamentId, userId: row.user_id, amountCents: 0, status: "comped" });
    markWaitlistConverted(row.id);
    // re-check capacity and close if needed
    const nowCount = countConfirmedEntries(tournamentId);
    if (nowCount >= t.max_slots) setTournamentOpen(tournamentId, false);
    return { ok:true, promoted:"comped", userId: row.user_id };
  }

  // create one-off Checkout for them and store the link
  const offerUrlTtl = epochPlusHours(WAITLIST_OFFER_TTL_HOURS);
  const session = await stripe.checkout.sessions.create({
    mode: "payment",
    customer_email: status?.email || undefined,
    line_items: [{
      price_data: { currency: "usd", unit_amount: amountCents, product_data: { name: `Tournament Entry (Offer) – ${tournamentId}` } },
      quantity: 1,
    }],
    success_url: `${process.env.APP_URL}/tournaments/${tournamentId}/success?session_id={CHECKOUT_SESSION_ID}`,
    cancel_url: `${process.env.APP_URL}/tournaments/${tournamentId}/cancel`,
    client_reference_id: `${row.user_id}:${tournamentId}`,
    metadata: { type: "tournament_entry", userId: row.user_id, tournamentId, amountCents: String(amountCents), waitlist: "1" },
    payment_intent_data: { metadata: { type: "tournament_entry", userId: row.user_id, tournamentId, waitlist: "1" } },
    allow_promotion_codes: false,
    // Note: Stripe expires sessions automatically after a while; TTL is for our UI.
  });

  markWaitlistOffered(row.id, { url: session.url, expiresAt: offerUrlTtl });
  // keep tournament open while offer pending
  setTournamentOpen(tournamentId, true);
  return { ok:true, promoted:"offered", userId: row.user_id, url: session.url, expiresAt: offerUrlTtl };
}
