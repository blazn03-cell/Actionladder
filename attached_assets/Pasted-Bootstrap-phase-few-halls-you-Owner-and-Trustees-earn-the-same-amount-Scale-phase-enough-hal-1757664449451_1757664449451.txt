Bootstrap phase (few halls): you (Owner) and Trustees earn the same amount.

Scale phase (enough halls): Operators “take over” the match ladder %, and you collect Operator Subscriptions (SaaS) as your main revenue.

Drop this next to your current file; it reuses the same storage pattern and cents convention.

// revenue_plus.ts
import { storage } from "./storage";
import { RETENTION_INCENTIVES } from "./retention"; // or same file if combined

export type Cents = number;

export interface RevenueReport {
  range: { start: Date; end: Date };
  mode: "actuals" | "forecast";
  phase: "bootstrap" | "scale";
  totals: {
    // inflows by source
    playerSubs: Cents;
    challengeFees: Cents;
    fanTipsGross: Cents;
    giftedSubsGross: Cents;
    operatorSubscriptions: Cents;

    grossInflow: Cents;

    // outflows/costs
    incentivesCost: Cents;
    operatorPayouts: Cents;
    trusteePayouts: Cents;
    ownerPayouts: Cents;     // YOU
    potAccruals: Cents;
    playerWinnings: Cents;

    // player net & platform remainder
    playersPaid: Cents;
    playerNet: Cents;

    platformNetAfterOwner: Cents; // sanity check bucket / reserve
  };
  byStakeholder: {
    players: {
      subsPaid: Cents;           // only the subs actually paid by players (excludes gifted)
      challengeFeesPaid: Cents;
      fanTipsReceived: Cents;    // after platform rake
      giftedMonthsReceived: number; // count of gifted subs
      winnings: Cents;
      incentivesWon: Cents;
      net: Cents;
    };
    operators: { inflow: Cents };
    trustees: { inflow: Cents };
    owner: { inflow: Cents }; // YOU
  };
  notes?: string[];
}

/* ---------- CONFIG FOR GIFTS & FANS & PROMOS ---------- */
export const ADDON_CONFIG = {
  fans: {
    platformRakePctDefault: 0.10, // 10% rake on fan tips
  },
  gifts: {
    // Gifted subscriptions are paid by fans/sponsors (counted as giftedSubsGross).
    // Player doesn't pay for that month; they still get service.
  },
  promos: {
    // Global promo toggle to comp some % of months (no cash collected).
    enabledByDefault: true,
  },
} as const;

/* ---------- ACTUALS (requires minimal new storage readers) ----------
 * storage.getFanTips({ start, end }) -> { playerId, amount, createdAt }
 * storage.getGiftedSubs({ start, end }) -> { playerId, amount, createdAt }
 * storage.getOperatorSubscriptions({ start, end }) -> { hallId, amount, createdAt }
 * storage.getDistributions(...) should also include kind "owner" if you already log it.
 */
export async function getRevenueReportActuals(
  start: Date,
  end: Date,
  opts: { hallsThresholdForScale: number; operatorHalls?: number }
): Promise<RevenueReport> {
  const operatorHalls = opts.operatorHalls ?? (await storage.countOperatorHalls());
  const phase: "bootstrap" | "scale" =
    operatorHalls >= opts.hallsThresholdForScale ? "scale" : "bootstrap";

  const [payments, distributions, incentives, fanTips, giftedSubs, opSubs] = await Promise.all([
    storage.getPayments({ start, end, types: ["subscription", "challenge_fee"] }),
    storage.getDistributions({ start, end }),
    storage.getIncentives({ start, end }),
    storage.getFanTips({ start, end }),
    storage.getGiftedSubs({ start, end }),
    storage.getOperatorSubscriptions({ start, end }),
  ]);

  const subsPaidByPlayers = sum(payments.filter(p => p.type === "subscription").map(p => p.amount));
  const challengeFees = sum(payments.filter(p => p.type === "challenge_fee").map(p => p.amount));
  const fanTipsGross = sum(fanTips.map(t => t.amount));
  const giftedSubsGross = sum(giftedSubs.map(g => g.amount));
  const operatorSubscriptions = sum(opSubs.map(s => s.amount));

  // Player-facing
  const fanRakePct = ADDON_CONFIG.fans.platformRakePctDefault;
  const fanTipsRake = Math.round(fanTipsGross * fanRakePct);
  const fanTipsToPlayers = fanTipsGross - fanTipsRake;

  const playerWinnings = sum(distributions.filter(d => d.kind === "player_winnings").map(d => d.amount));
  const incentivesCost = sum(incentives.map(i => i.bonusAmount));
  const incentivesWon = incentivesCost;

  // Payouts
  let operatorPayouts = sum(distributions.filter(d => d.kind === "operator").map(d => d.amount));
  let trusteePayouts = sum(distributions.filter(d => d.kind === "trustee").map(d => d.amount));
  let ownerPayoutsLogged = sum(distributions.filter(d => d.kind === "owner").map(d => d.amount));
  const potAccruals = sum(distributions.filter(d => d.kind === "pot").map(d => d.amount));

  // Phase policy:
  // - Bootstrap: ensure Owner inflow == Trustee inflow (adjust from platform remainder if needed)
  // - Scale: Owner inflow = operatorSubscriptions (SaaS). If you already logged owner, keep it; otherwise, attribute here.
  const grossInflow =
    subsPaidByPlayers + challengeFees + fanTipsGross + giftedSubsGross + operatorSubscriptions;

  const platformOutflowsBeforeOwner =
    operatorPayouts + trusteePayouts + potAccruals + playerWinnings + incentivesCost + fanTipsToPlayers;

  let ownerPayouts = ownerPayoutsLogged;
  if (phase === "bootstrap") {
    if (ownerPayouts < trusteePayouts) {
      const topUpNeeded = trusteePayouts - ownerPayouts;
      const platformRemainder = grossInflow - platformOutflowsBeforeOwner - ownerPayouts;
      const topUp = Math.max(0, Math.min(topUpNeeded, platformRemainder));
      ownerPayouts += topUp;
    } else if (ownerPayouts > trusteePayouts) {
      // Optional: clamp down to parity
      ownerPayouts = trusteePayouts;
    }
  } else {
    // SCALE: attribute SaaS to Owner if not already logged
    if (ownerPayouts < operatorSubscriptions) {
      const delta = operatorSubscriptions - ownerPayouts;
      ownerPayouts += delta;
    }
  }

  const playersPaid = subsPaidByPlayers + challengeFees; // fans pay tips + gifted subs, not players
  const playerNet = (playerWinnings + incentivesWon + fanTipsToPlayers) - playersPaid;

  const platformNetAfterOwner =
    grossInflow - (platformOutflowsBeforeOwner + ownerPayouts);

  return {
    range: { start, end },
    mode: "actuals",
    phase,
    totals: {
      playerSubs: subsPaidByPlayers,
      challengeFees,
      fanTipsGross,
      giftedSubsGross,
      operatorSubscriptions,
      grossInflow,
      incentivesCost,
      operatorPayouts,
      trusteePayouts,
      ownerPayouts,
      potAccruals,
      playerWinnings,
      playersPaid,
      playerNet,
      platformNetAfterOwner,
    },
    byStakeholder: {
      players: {
        subsPaid: subsPaidByPlayers,
        challengeFeesPaid: challengeFees,
        fanTipsReceived: fanTipsToPlayers,
        giftedMonthsReceived: giftedSubs.length,
        winnings: playerWinnings,
        incentivesWon,
        net: playerNet,
      },
      operators: { inflow: operatorPayouts },
      trustees: { inflow: trusteePayouts },
      owner: { inflow: ownerPayouts },
    },
    notes: [
      `Bootstrap parity: owner inflow is matched to trustees (from platform remainder).`,
      `Scale phase: owner inflow sourced from Operator Subscriptions (SaaS).`,
      `Fan tips: ${Math.round(fanRakePct * 100)}% rake to platform; rest to players.`,
      `Gifted subs: revenue counted under giftedSubsGross; players don’t pay those months.`,
    ],
  };
}

/* ---------- FORECAST WITH GIFTS, FANS, FREE MONTHS & PHASES ---------- */
export interface ForecastInputs {
  // Ladder usage
  players: number;
  matchesPerPlayerPerMonth: number;     // e.g., 8
  subscriptionCents: Cents;             // player sub sticker price
  challengeFeeCents: Cents;             // per match platform fee (not side action)
  weeks: number;                        // 4–4.33

  // Fans & gifts
  fanTipsPerPlayerPerMonthCents?: Cents;   // avg tips inflow to the system per player
  fanPlatformRakePct?: number;             // default 0.10
  giftedSubPct?: number;                    // % of players whose sub is paid by fans
  compedFreePct?: number;                   // % of players fully comped for the month (no revenue)

  // Incentives & pots
  potAccrualPct?: number;                // % of gross to pots
  expectedStreakCostPerPlayerCents?: Cents;
  expectedProgressCostPerPlayerCents?: Cents;
  weeklyMiniPrizeCents?: Cents;
  avgPlayerWinningsVsFeesPct?: number;

  // Rev shares (per ladder fees)
  operatorSharePct: number;              // applied to shareBase
  trusteesSharePct: number;              // combined trustees
  shareBase: "gross" | "subs_only" | "fees_only";

  // Operator SaaS
  operatorHalls: number;
  hallsThresholdForScale: number;        // when >= threshold => scale phase
  operatorPlanCents: Cents;              // per hall per month paid to owner (SaaS)
}

export function forecastRevenue(inputs: ForecastInputs): RevenueReport {
  const {
    players,
    matchesPerPlayerPerMonth,
    subscriptionCents,
    challengeFeeCents,
    weeks,

    fanTipsPerPlayerPerMonthCents = 0,
    fanPlatformRakePct = ADDON_CONFIG.fans.platformRakePctDefault,
    giftedSubPct = 0,   // part paid by fans
    compedFreePct = 0,  // part fully free (promo)

    potAccrualPct = 0.05,
    expectedStreakCostPerPlayerCents = 500,
    expectedProgressCostPerPlayerCents = 300,
    weeklyMiniPrizeCents = RETENTION_INCENTIVES.WEEKLY_MINI_PRIZES.amount,
    avgPlayerWinningsVsFeesPct = 0.55,

    operatorSharePct,
    trusteesSharePct,
    shareBase,

    operatorHalls,
    hallsThresholdForScale,
    operatorPlanCents,
  } = inputs;

  const phase: "bootstrap" | "scale" =
    operatorHalls >= hallsThresholdForScale ? "scale" : "bootstrap";

  const totalMatches = Math.round(players * matchesPerPlayerPerMonth);

  // Subscriptions breakdown
  const giftedPlayers = Math.round(players * giftedSubPct);
  const compedPlayers = Math.round(players * compedFreePct);
  const payingPlayers = Math.max(0, players - giftedPlayers - compedPlayers);

  const subsPaidByPlayers = payingPlayers * subscriptionCents; // from players
  const giftedSubsGross = giftedPlayers * subscriptionCents;   // from fans
  const compedSubs = compedPlayers * subscriptionCents;        // $0 collected

  // Challenge fees (players pay these)
  const challengeFees = totalMatches * challengeFeeCents;

  // Fan tips
  const fanTipsGross = Math.round(players * fanTipsPerPlayerPerMonthCents);
  const fanTipsRake = Math.round(fanTipsGross * fanPlatformRakePct);
  const fanTipsToPlayers = fanTipsGross - fanTipsRake;

  // Operator SaaS
  const operatorSubscriptions = operatorHalls * operatorPlanCents;

  // Gross inflow to platform
  const grossInflow =
    subsPaidByPlayers + giftedSubsGross + challengeFees + fanTipsGross + operatorSubscriptions;

  // Choose share base for rev shares
  const shareBaseAmount =
    shareBase === "gross" ? (subsPaidByPlayers + giftedSubsGross + challengeFees)
    : shareBase === "subs_only" ? (subsPaidByPlayers + giftedSubsGross)
    : challengeFees; // fees_only

  let operatorPayouts = Math.round(shareBaseAmount * operatorSharePct);
  let trusteePayouts = Math.round(shareBaseAmount * trusteesSharePct);

  // Incentives & pots & winnings
  const weeklyPrizeCost = Math.round(weeks * weeklyMiniPrizeCents);
  const streakAccrual = players * expectedStreakCostPerPlayerCents;
  const progressAccrual = players * expectedProgressCostPerPlayerCents;
  const incentivesCost = weeklyPrizeCost + streakAccrual + progressAccrual;

  const playerWinnings = Math.round(challengeFees * avgPlayerWinningsVsFeesPct);
  const potAccruals = Math.round(grossInflow * potAccrualPct);

  // Bootstrap parity vs Scale policy for Owner
  let ownerPayouts = 0;
  if (phase === "bootstrap") {
    // Make Owner inflow == Trustees inflow (funded from platform remainder)
    ownerPayouts = trusteePayouts;
  } else {
    // Scale: Owner collects SaaS (operator subscriptions) as primary income
    ownerPayouts = operatorSubscriptions;
  }

  const playersPaid = subsPaidByPlayers + challengeFees; // gifted & tips are not paid by players
  const incentivesWon = incentivesCost;
  const playerNet = (playerWinnings + incentivesWon + fanTipsToPlayers) - playersPaid;

  const platformOutflows =
    operatorPayouts + trusteePayouts + potAccruals + playerWinnings + incentivesCost + fanTipsToPlayers + ownerPayouts;

  const platformNetAfterOwner = grossInflow - platformOutflows;

  return {
    range: { start: new Date(), end: new Date() },
    mode: "forecast",
    phase,
    totals: {
      playerSubs: subsPaidByPlayers,
      challengeFees,
      fanTipsGross,
      giftedSubsGross,
      operatorSubscriptions,
      grossInflow,
      incentivesCost,
      operatorPayouts,
      trusteePayouts,
      ownerPayouts,
      potAccruals,
      playerWinnings,
      playersPaid,
      playerNet,
      platformNetAfterOwner,
    },
    byStakeholder: {
      players: {
        subsPaid: subsPaidByPlayers,
        challengeFeesPaid: challengeFees,
        fanTipsReceived: fanTipsToPlayers,
        giftedMonthsReceived: giftedPlayers,
        winnings: playerWinnings,
        incentivesWon,
        net: playerNet,
      },
      operators: { inflow: operatorPayouts },
      trustees: { inflow: trusteePayouts },
      owner: { inflow: ownerPayouts },
    },
    notes: [
      `totalMatches ≈ players × matchesPerPlayerPerMonth = ${totalMatches}`,
      `giftedPlayers=${giftedPlayers}, compedPlayers=${compedPlayers}, payingPlayers=${payingPlayers}`,
      `Bootstrap: owner == trustees. Scale: owner = operatorSubscriptions.`,
      `Fan tips rake = ${Math.round(fanPlatformRakePct * 100)}% to platform; remainder to players.`,
      `compedSubs (promo) are provided as free months; no cash collected.`,
    ],
  };
}

/* ---------- HELPERS ---------- */
function sum(nums: number[]): number {
  return nums.reduce((a, b) => a + (b || 0), 0);
}

Quick examples
// BOOTSTRAP (e.g., 2 halls < threshold 5)
const boot = forecastRevenue({
  players: 30,
  matchesPerPlayerPerMonth: 8,
  subscriptionCents: 6000,    // $60
  challengeFeeCents: 300,     // $3 fee per match
  weeks: 4.3,

  fanTipsPerPlayerPerMonthCents: 200, // $2 avg tips each
  fanPlatformRakePct: 0.10,
  giftedSubPct: 0.10,  // 10% of subs paid by fans
  compedFreePct: 0.05, // 5% comped during promo

  potAccrualPct: 0.06,
  expectedStreakCostPerPlayerCents: 500,
  expectedProgressCostPerPlayerCents: 300,
  weeklyMiniPrizeCents: 5000,
  avgPlayerWinningsVsFeesPct: 0.6,

  operatorSharePct: 0.35,
  trusteesSharePct: 0.20,
  shareBase: "gross",

  operatorHalls: 2,
  hallsThresholdForScale: 5,
  operatorPlanCents: 15000,   // $150 per hall (SaaS)
});

// SCALE (e.g., 6 halls ≥ threshold 5)
const scale = forecastRevenue({
  ...boot,
  operatorHalls: 6,
});