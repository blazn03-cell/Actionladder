import React, { useMemo, useState } from "react";
import { NavLink } from "react-router-dom";

// This module adds: Elo ratings, McMahon-style pairing assistant, and a ratings rebuilder.
// It uses your existing Store (useStore) via props you pass from the Operator page.

export default function RatingsPairingPanel({ store }) {
  const { players, matches, addMatch, updatePlayer, settings } = store;

  const [initialRating, setInitialRating] = useState(settings.initialRating ?? 1200);
  const [kFactor, setKFactor] = useState(settings.kFactor ?? 24);
  const [bandSize, setBandSize] = useState(settings.bandSize ?? 200);
  const [avoidDays, setAvoidDays] = useState(settings.avoidRematchDays ?? 30);
  const [baseBet, setBaseBet] = useState(100);
  const [mode, setMode] = useState("extra_cash"); // weight | extra_cash
  const [when, setWhen] = useState("");
  const [suggested, setSuggested] = useState([]);

  const roster = useMemo(() => players.map(p => ({
    ...p,
    rating: Number.isFinite(p.rating) ? p.rating : initialRating,
  })).sort((a,b) => (b.rating || 0) - (a.rating || 0)), [players, initialRating]);

  function handleRebuild() {
    // Reset everyone to initialRating, then replay settled matches chronologically
    const ordered = [...matches].filter(m => m.settled && m.result?.winner).sort((a,b) => (a.createdAt||0)-(b.createdAt||0));
    const ratingMap = new Map(roster.map(p => [p.id, initialRating]));
    for (const m of ordered) {
      const RA = ratingMap.get(m.favoriteId) ?? initialRating;
      const RB = ratingMap.get(m.challengerId) ?? initialRating;
      const scoreA = m.result.winner === "favorite" ? 1 : 0;
      const { newA, newB } = eloUpdatePair(RA, RB, scoreA, kFactor);
      ratingMap.set(m.favoriteId, newA);
      ratingMap.set(m.challengerId, newB);
    }
    // write back
    for (const [id, r] of ratingMap.entries()) {
      updatePlayer(id, { rating: round2(r) });
    }
    alert("Ratings rebuilt from settled matches.");
  }

  function handleSuggest() {
    const pairs = mcmahonSuggest(roster, matches, { bandSize, avoidDays });
    setSuggested(pairs);
  }

  function handleCreateMatches() {
    if (!suggested.length) { alert("No suggested pairs yet"); return; }
    for (const { favorite, challenger } of suggested) {
      addMatch({ favoriteId: favorite.id, challengerId: challenger.id, base: baseBet, mode, weightNote: mode === 'weight' ? '+1 on the wire' : '', date: when ? new Date(when).toISOString() : null, escrow: { favPaid: false, chalPaid: false }, settled: false, status: 'scheduled' });
    }
    alert(`Created ${suggested.length} matches.`);
  }

  return (
    <div className="rounded-2xl border p-4 text-sm space-y-4">
      <div className="flex items-center justify-between">
        <h4 className="font-semibold">Elo Ratings + McMahon Pairing (AI‑Lite)</h4>
        <NavLink to="/transparency" className="underline text-xs">Player Transparency →</NavLink>
      </div>

      {/* Ratings Rebuild */}
      <div className="grid md:grid-cols-4 gap-2">
        <Num label="Initial Rating" v={initialRating} set={setInitialRating} min={800} max={2000} step={10} />
        <Num label="K‑Factor" v={kFactor} set={setKFactor} min={8} max={48} step={1} />
        <button className="px-3 py-2 rounded-xl border" onClick={handleRebuild}>Rebuild Ratings from Matches</button>
      </div>

      {/* Pairing Assistant */}
      <div className="rounded-xl border p-3 bg-gray-50 space-y-2">
        <div className="font-semibold">Pairing Assistant (McMahon bands)</div>
        <div className="grid md:grid-cols-5 gap-2">
          <Num label="Band Size" v={bandSize} set={setBandSize} min={50} max={400} step={10} />
          <Num label="Avoid Rematches (days)" v={avoidDays} set={setAvoidDays} min={0} max={120} step={5} />
          <Num label="Base Bet ($)" v={baseBet} set={setBaseBet} min={50} max={300} step={5} />
          <label className="text-xs block">
            <div className="mb-1 font-medium">Mode</div>
            <select value={mode} onChange={(e)=>setMode(e.target.value)} className="w-full border rounded-xl px-3 py-2">
              <option value="extra_cash">More Cash (1.2×)</option>
              <option value="weight">Give Weight</option>
            </select>
          </label>
          <label className="text-xs block">
            <div className="mb-1 font-medium">Date & Time</div>
            <input type="datetime-local" value={when} onChange={(e)=>setWhen(e.target.value)} className="w-full border rounded-xl px-3 py-2"/>
          </label>
        </div>
        <div className="flex gap-2">
          <button className="px-3 py-2 rounded-xl bg-black text-white" onClick={handleSuggest}>Suggest Pairings</button>
          <button className="px-3 py-2 rounded-xl border" onClick={handleCreateMatches}>Create Matches</button>
        </div>
        {!!suggested.length && (
          <table className="w-full text-xs mt-2">
            <thead><tr><th className="text-left">Favorite</th><th className="text-left">Challenger</th><th className="text-left">Band</th><th className="text-left">Why this pair</th></tr></thead>
            <tbody>
              {suggested.map((p,i)=> (
                <tr key={i} className="border-t">
                  <td className="py-1">{p.favorite.name} ({p.favorite.rating})</td>
                  <td>{p.challenger.name} ({p.challenger.rating})</td>
                  <td>{p.bandLabel}</td>
                  <td>{p.reason}</td>
                </tr>
              ))}
            </tbody>
          </table>
        )}
        {!suggested.length && <div className="text-xs text-muted-foreground">No pairs yet. Click Suggest Pairings.</div>}
      </div>
    </div>
  );
}

function Num({ label, v, set, min, max, step }) {
  return (
    <label className="text-xs block">
      <div className="mb-1 font-medium">{label}</div>
      <input type="number" value={v} onChange={(e)=>set(Number(e.target.value))} min={min} max={max} step={step} className="w-full border rounded-xl px-3 py-2" />
    </label>
  );
}

/* ================= Elo helpers ================= */
export function eloExpected(rA, rB) {
  return 1 / (1 + Math.pow(10, (rB - rA) / 400));
}
export function eloUpdatePair(rA, rB, scoreA, K=24) {
  const eA = eloExpected(rA, rB);
  const eB = 1 - eA;
  const newA = rA + K * (scoreA - eA);
  const newB = rB + K * ((1 - scoreA) - eB);
  return { newA, newB };
}

/* =============== McMahon assistant =============== */
function bandIndex(rating, bandSize, base=1000) {
  return Math.floor((rating - base) / bandSize);
}
function lastMetWithinDays(aId, bId, matches, days) {
  if (!days || days <= 0) return false;
  const since = Date.now() - days*24*3600*1000;
  for (const m of matches) {
    if (!m.settled && !m.date) continue;
    const t = m.date ? new Date(m.date).getTime() : (m.createdAt||0);
    if (t < since) continue;
    const pa = [m.favoriteId, m.challengerId].includes(aId);
    const pb = [m.favoriteId, m.challengerId].includes(bId);
    if (pa && pb) return true;
  }
  return false;
}
export function mcmahonSuggest(players, matches, { bandSize=200, avoidDays=30 }={}) {
  // Group by band
  const byBand = new Map();
  for (const p of players) {
    const idx = bandIndex(p.rating || 1200, bandSize);
    if (!byBand.has(idx)) byBand.set(idx, []);
    byBand.get(idx).push(p);
  }
  for (const v of byBand.values()) v.sort((a,b)=> (b.rating||0)-(a.rating||0));

  const suggestions = [];
  // For each band, pair neighbors while avoiding rematches
  for (const [idx, list] of Array.from(byBand.entries()).sort((a,b)=> b[0]-a[0])) {
    const used = new Set();
    for (let i=0;i<list.length;i++) {
      if (used.has(list[i].id)) continue;
      let best = null; let bestGap = Infinity;
      for (let j=i+1;j<list.length;j++) {
        if (used.has(list[j].id)) continue;
        if (avoidDays && lastMetWithinDays(list[i].id, list[j].id, matches, avoidDays)) continue;
        const gap = Math.abs((list[i].rating||0) - (list[j].rating||0));
        if (gap < bestGap) { bestGap = gap; best = list[j]; }
      }
      // if none found, relax rematch rule
      if (!best) {
        for (let j=i+1;j<list.length;j++) {
          if (used.has(list[j].id)) continue;
          const gap = Math.abs((list[i].rating||0) - (list[j].rating||0));
          if (gap < bestGap) { bestGap = gap; best = list[j]; }
        }
      }
      if (best) {
        const favorite = (list[i].rating || 0) >= (best.rating || 0) ? list[i] : best;
        const challenger = favorite === list[i] ? best : list[i];
        used.add(favorite.id); used.add(challenger.id);
        suggestions.push({ favorite, challenger, band: idx, bandLabel: `Band ${idx}`, reason: `Nearest rating in band (gap ${bestGap})` });
      }
    }
  }
  return suggestions;
}

function round2(n){ return Math.round(n*100)/100; }
