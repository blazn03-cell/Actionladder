// ===============================
// src/routes/billing.ts (drop-in replacement with Waitlist + Admin Auth)
// ===============================
import express from "express";
import Stripe from "stripe";
import jwt from "jsonwebtoken";
import cookieParser from "cookie-parser";
import { resolveTierByPlayers, getPriceIdForTier, validatePlayerCountForTier } from "../config/stripeTiers";
import { CreateCheckoutBody } from "../types/billing";

const router = express.Router();
router.use(cookieParser());

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY as string, { apiVersion: "2024-06-20" });

// ======== In‑Memory Demo Store (replace with your DB) ========
interface HallRec {
  hallId: string;
  operatorId: string;
  currentTier: "Small" | "Medium" | "Large" | "Mega";
  stripeCustomerId?: string;
  stripeSubscriptionId?: string;
  waitlist: { targetTier: "Mega"; signups: { name: string; email: string }[] };
}
const HALLS = new Map<string, HallRec>();

// Seed helper (create if missing)
function getOrCreateHall(hallId: string, operatorId: string): HallRec {
  let rec = HALLS.get(hallId);
  if (!rec) {
    rec = { hallId, operatorId, currentTier: "Small", waitlist: { targetTier: "Mega", signups: [] } };
    HALLS.set(hallId, rec);
  }
  return rec;
}

// Configurable threshold: how many waitlist signups needed to unlock Mega from Large
const WAITLIST_MEGA_MIN = Number(process.env.WAITLIST_MEGA_MIN ?? 15);
function hasMetWaitlistThreshold(hall: HallRec): boolean {
  return hall.waitlist.signups.length >= WAITLIST_MEGA_MIN;
}

// Notify operator stub (email/SMS integration goes here)
async function notifyOperatorThresholdReached(hall: HallRec) {
  console.log(`WAITLIST REACHED for hall ${hall.hallId}. Notify operator ${hall.operatorId}.`);
  // TODO: integrate email (SendGrid/Mailgun) or SMS (Twilio)
}

// Helper: build absolute URL for redirects
function url(path = ""): string {
  const base = process.env.APP_BASE_URL ?? "http://localhost:3000";
  return `${base}${path.startsWith("/") ? path : "/" + path}`;
}

// ======== ADMIN AUTH (single owner login) ========
const ADMIN_EMAIL = process.env.ADMIN_EMAIL ?? "admin@example.com";
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD ?? "change-me";
const ADMIN_JWT_SECRET = process.env.ADMIN_JWT_SECRET ?? "super-secret-change-me";

function signAdminJwt() {
  return jwt.sign({ role: "ADMIN" }, ADMIN_JWT_SECRET, { expiresIn: "7d" });
}

function requireAdmin(req: express.Request, res: express.Response, next: express.NextFunction) {
  try {
    const token = (req.cookies?.admin_token) || (req.headers.authorization?.replace("Bearer ", ""));
    if (!token) return res.status(401).json({ error: "Unauthorized" });
    const payload = jwt.verify(token, ADMIN_JWT_SECRET) as any;
    if (payload?.role !== "ADMIN") return res.status(403).json({ error: "Forbidden" });
    return next();
  } catch {
    return res.status(401).json({ error: "Unauthorized" });
  }
}

router.post("/admin/login", express.json(), (req, res) => {
  const { email, password } = req.body as { email: string; password: string };
  if (email === ADMIN_EMAIL && password === ADMIN_PASSWORD) {
    const token = signAdminJwt();
    res.cookie("admin_token", token, { httpOnly: true, sameSite: "lax", secure: false, maxAge: 7 * 24 * 3600 * 1000 });
    return res.json({ ok: true, token });
  }
  return res.status(401).json({ error: "Invalid credentials" });
});

// ======== CHECKOUT (with Mega waitlist guard + small/medium free upgrade) ========
router.post("/checkout", async (req, res) => {
  try {
    const { playerCount, hallId, operatorId, email } = req.body as CreateCheckoutBody;
    const tier = resolveTierByPlayers(Number(playerCount));
    const price = getPriceIdForTier(tier);

    const hall = getOrCreateHall(hallId, operatorId);

    // Guard: Large → Mega requires waitlist threshold
    if (tier.name === "Mega" && hall.currentTier === "Large" && !hasMetWaitlistThreshold(hall)) {
      return res.status(400).json({
        error: `Mega upgrade locked. Build a waitlist of at least ${WAITLIST_MEGA_MIN} players first. Current: ${hall.waitlist.signups.length}.`,
        required: WAITLIST_MEGA_MIN,
        current: hall.waitlist.signups.length,
      });
    }

    // Note: Small & Medium can upgrade anytime by design.

    const session = await stripe.checkout.sessions.create({
      mode: "subscription",
      line_items: [{ price, quantity: 1 }],
      customer_email: email,
      success_url: url("/billing/success?session_id={CHECKOUT_SESSION_ID}"),
      cancel_url: url("/billing/cancel"),
      metadata: { hallId, operatorId, playerCount: String(playerCount), tier: tier.name },
      subscription_data: { metadata: { hallId, operatorId, tier: tier.name } },
    });

    return res.json({ url: session.url, tier: tier.name });
  } catch (err: any) {
    console.error("/checkout error", err);
    return res.status(500).json({ error: err.message });
  }
});

// ======== CUSTOMER PORTAL ========
router.get("/portal", async (req, res) => {
  try {
    const customerId = String(req.query.customer_id || "");
    if (!customerId) return res.status(400).json({ error: "customer_id required" });
    const portal = await stripe.billingPortal.sessions.create({ customer: customerId, return_url: url("/billing") });
    return res.json({ url: portal.url });
  } catch (err: any) {
    console.error("/portal error", err);
    return res.status(500).json({ error: err.message });
  }
});

// ======== WEBHOOK (store customer/subscription) ========
router.post("/webhook", express.raw({ type: "application/json" }), (req, res) => {
  const sig = req.headers["stripe-signature"] as string;
  let event: Stripe.Event;
  try {
    event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET as string);
  } catch (err: any) {
    console.error("Webhook signature verification failed.", err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  switch (event.type) {
    case "checkout.session.completed": {
      const session = event.data.object as Stripe.Checkout.Session;
      const hallId = session.metadata?.hallId as string | undefined;
      const operatorId = session.metadata?.operatorId as string | undefined;
      if (hallId && operatorId) {
        const hall = getOrCreateHall(hallId, operatorId);
        hall.stripeCustomerId = session.customer as string | undefined;
        hall.stripeSubscriptionId = session.subscription as string | undefined;
        const t = session.metadata?.tier as HallRec["currentTier"] | undefined;
        if (t) hall.currentTier = t;
      }
      break;
    }
    case "customer.subscription.updated":
    case "customer.subscription.created": {
      const sub = event.data.object as Stripe.Subscription;
      // TODO: sync subscription status to your DB
      break;
    }
    case "customer.subscription.deleted": {
      const sub = event.data.object as Stripe.Subscription;
      // TODO: mark hall canceled/suspended in your DB
      break;
    }
    default:
      break;
  }

  res.json({ received: true });
});

// ======== WAITLIST ROUTES ========
router.post("/waitlist/:hallId/signup", express.json(), async (req, res) => {
  const { hallId } = req.params;
  const { name, email, operatorId } = req.body as { name: string; email: string; operatorId: string };
  if (!name || !email) return res.status(400).json({ error: "name and email required" });

  const hall = getOrCreateHall(hallId, operatorId || "unknown");
  const exists = hall.waitlist.signups.some(s => s.email.toLowerCase() === email.toLowerCase());
  if (!exists) hall.waitlist.signups.push({ name, email });

  const met = hasMetWaitlistThreshold(hall);
  if (met && hall.currentTier === "Large") await notifyOperatorThresholdReached(hall);

  return res.json({ count: hall.waitlist.signups.length, required: WAITLIST_MEGA_MIN, met });
});

router.get("/waitlist/:hallId/status", (req, res) => {
  const { hallId } = req.params;
  const hall = HALLS.get(hallId);
  if (!hall) return res.status(404).json({ error: "Hall not found" });
  return res.json({ count: hall.waitlist.signups.length, required: WAITLIST_MEGA_MIN, met: hasMetWaitlistThreshold(hall) });
});

export default router;

// ===============================
// .env additions
// ===============================
// ADMIN_EMAIL=youremail@domain.com
// ADMIN_PASSWORD=supersecret
// ADMIN_JWT_SECRET=long_random_string
// WAITLIST_MEGA_MIN=15

// ===============================
// server wiring (reminder)
// ===============================
// import express from "express";
// import billingRoutes from "./routes/billing";
// const app = express();
// app.use(express.json({ limit: "1mb" }));
// app.use("/api/billing", billingRoutes);
// app.listen(process.env.PORT || 4000);


// ===============================
// Upgrade Gate + Waitlist Widget + Admin Login (React/Tailwind)
// ===============================

import React, { useEffect, useState } from "react";
import CheckoutButton from "./CheckoutButton";

// --- Admin Login (owner only) ---
export function AdminLogin({ onAuthed }: { onAuthed: () => void }) {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState<string | null>(null);

  async function login() {
    setError(null);
    const res = await fetch("/api/billing/admin/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ email, password }),
    });
    if (!res.ok) {
      const data = await res.json().catch(() => ({ error: res.statusText }));
      setError(data.error || "Login failed");
      return;
    }
    onAuthed();
  }

  return (
    <div className="max-w-sm space-y-3 rounded-2xl border p-4">
      <h3 className="text-lg font-bold">Owner Login</h3>
      <input className="w-full rounded-xl border p-2" placeholder="Email" value={email} onChange={(e) => setEmail(e.target.value)} />
      <input className="w-full rounded-xl border p-2" type="password" placeholder="Password" value={password} onChange={(e) => setPassword(e.target.value)} />
      {error && <p className="text-sm text-red-600">{error}</p>}
      <button onClick={login} className="rounded-xl bg-black px-4 py-2 text-white">Login</button>
    </div>
  );
}

// --- Waitlist status fetcher ---
async function fetchWaitlistStatus(hallId: string): Promise<{ count: number; required: number; met: boolean }> {
  const res = await fetch(`/api/billing/waitlist/${hallId}/status`);
  if (!res.ok) throw new Error("Failed to load waitlist status");
  return res.json();
}

async function joinWaitlist(hallId: string, operatorId: string, name: string, email: string) {
  const res = await fetch(`/api/billing/waitlist/${hallId}/signup`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ name, email, operatorId }),
  });
  if (!res.ok) {
    const data = await res.json().catch(() => ({ error: res.statusText }));
    throw new Error(data.error || "Failed to join waitlist");
  }
  return res.json();
}

export function WaitlistWidget({ hallId, operatorId }: { hallId: string; operatorId: string }) {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [status, setStatus] = useState<{ count: number; required: number; met: boolean } | null>(null);
  const [msg, setMsg] = useState<string | null>(null);

  useEffect(() => {
    fetchWaitlistStatus(hallId).then(setStatus).catch(() => {});
  }, [hallId]);

  async function submit() {
    setMsg(null);
    const data = await joinWaitlist(hallId, operatorId, name, email);
    setStatus(data);
    setMsg(`Thanks! ${data.count}/${data.required} signed up.`);
    setName("");
    setEmail("");
  }

  if (!status) return <p className="text-sm text-gray-500">Loading waitlist…</p>;

  return (
    <div className="rounded-2xl border p-4 space-y-3">
      <h4 className="font-semibold">Upgrade to Mega – Join the Waitlist</h4>
      <p className="text-sm text-gray-600">We need <b>{status.required}</b> signups to unlock Mega. Current: <b>{status.count}</b>.</p>
      <div className="flex gap-2">
        <input className="flex-1 rounded-xl border p-2" placeholder="Your name" value={name} onChange={(e) => setName(e.target.value)} />
        <input className="flex-1 rounded-xl border p-2" placeholder="Your email" value={email} onChange={(e) => setEmail(e.target.value)} />
        <button onClick={submit} className="rounded-xl bg-black px-4 py-2 text-white">Notify Me</button>
      </div>
      {msg && <p className="text-sm text-green-600">{msg}</p>}
    </div>
  );
}

// --- Upgrade Gate ---
export function UpgradeGate({
  hallId,
  operatorId,
  playerCount,
  email,
  customerId,
  currentTier,
}: {
  hallId: string;
  operatorId: string;
  playerCount: number;
  email?: string;
  customerId?: string; // if present, show Manage Billing instead
  currentTier: "Small" | "Medium" | "Large" | "Mega";
}) {
  const nextTier = playerCount <= 15 ? "Small" : playerCount <= 25 ? "Medium" : playerCount <= 40 ? "Large" : "Mega";

  if (currentTier === "Mega") {
    return <p className="text-sm text-gray-600">You’re already on Mega (unlimited).</p>;
  }

  // Small/Medium: allow instant upgrade (Checkout)
  if (nextTier === "Small" || nextTier === "Medium" || (currentTier !== "Large" && nextTier === "Large")) {
    return (
      <CheckoutButton
        hallId={hallId}
        operatorId={operatorId}
        playerCount={playerCount}
        email={email}
        label={`Upgrade to ${nextTier}`}
      />
    );
  }

  // Large → Mega: require waitlist until threshold met
  const [status, setStatus] = useState<{ count: number; required: number; met: boolean } | null>(null);
  useEffect(() => {
    if (currentTier === "Large" && nextTier === "Mega") {
      fetchWaitlistStatus(hallId).then(setStatus).catch(() => {});
    }
  }, [hallId, currentTier, nextTier]);

  if (currentTier === "Large" && nextTier === "Mega") {
    if (!status) return <p className="text-sm text-gray-500">Checking waitlist…</p>;
    if (!status.met) {
      return (
        <div className="space-y-3">
          <p className="text-sm">Mega upgrade locked until waitlist hits <b>{status.required}</b>. Current: <b>{status.count}</b>.</p>
          <WaitlistWidget hallId={hallId} operatorId={operatorId} />
        </div>
      );
    }
    // If threshold met, show Checkout
    return (
      <CheckoutButton
        hallId={hallId}
        operatorId={operatorId}
        playerCount={playerCount}
        email={email}
        label="Upgrade to Mega"
      />
    );
  }

  return null;
}
