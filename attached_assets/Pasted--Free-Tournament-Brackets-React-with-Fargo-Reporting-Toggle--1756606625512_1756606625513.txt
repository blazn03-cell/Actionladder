// Free Tournament Brackets (React) – with Fargo Reporting Toggle
// ------------------------------------------------------------
// ✅ Purpose: Standalone "Tournament Mode" for your free version.
// - Anyone can sign up when an operator is running a tournament
// - Randomized seeding into single-elimination brackets (double-elim stubbed)
// - Phone camera photo → OCR (Tesseract.js) → auto-fill match winners
// - Manual tap to set winner if OCR fails
// - Local persistence (localStorage) so refresh won't lose state
// - Winner poster generator (downloadable PNG)
// - NEW: "Report to Fargo (beta)" toggle + CSV export
//
// ⚙️ How to use (Vite + React recommended):
// 1) npm i tesseract.js
// 2) Drop this component into your app and render <FreeTournament />
// 3) On mobile, the photo picker opens the camera via `capture="environment"`
// 4) Optional: swap localStorage with your DB (Supabase/Firebase) — marked TODOs
// ------------------------------------------------------------

import React, { useEffect, useMemo, useRef, useState } from "react";

// -------------------- Types --------------------
interface Player {
  id: string;
  name: string;
}

interface Match {
  id: string;
  round: number; // 1-indexed
  a: Player | null; // left/top
  b: Player | null; // right/bottom
  scoreA?: number;
  scoreB?: number;
  winnerId?: string; // a.id or b.id
  nextMatchId?: string; // winner link forward
  nextSlot?: "a" | "b"; // where the winner goes next
  // Double-elim extras
  bracket?: "W" | "L" | "GF"; // Winners, Losers, Grand Final
  loserNextMatchId?: string; // where the loser goes (only for W bracket)
  loserNextSlot?: "a" | "b";
}

interface BracketState {
  id: string;
  name: string;
  format: "single" | "double"; // double is stubbed below
  players: Player[];
  matches: Match[];
  createdAt: number;
}

// Fargo reporting row (simple CSV-ready)
interface ReportRow {
  tournament: string;
  dateISO: string;
  round: number;
  playerA: string;
  playerB: string;
  scoreA: number | "";
  scoreB: number | "";
  winner: string;
}

// -------------------- Utils --------------------
const uid = () => Math.random().toString(36).slice(2, 10);

function shuffle<T>(arr: T[]): T[] {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = crypto.getRandomValues(new Uint32Array(1))[0] % (i + 1);
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function nextPowerOfTwo(n: number) {
  if (n < 1) return 1;
  return 1 << (32 - Math.clz32(n - 1));
}

function saveLocal(key: string, value: any) {
  try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
}
function loadLocal<T>(key: string, fallback: T): T {
  try {
    const raw = localStorage.getItem(key);
    return raw ? (JSON.parse(raw) as T) : fallback;
  } catch {
    return fallback;
  }
}

// -------------------- OCR --------------------
async function ocrImage(file: File): Promise<string> {
  // Dynamic import to keep initial bundle small
  const { createWorker } = await import("tesseract.js");
  const worker = await createWorker({ logger: () => {} });
  try {
    await worker.loadLanguage("eng");
    await worker.initialize("eng");
    const { data } = await worker.recognize(file);
    await worker.terminate();
    return data.text || "";
  } catch (e) {
    try { await worker.terminate(); } catch {}
    return "";
  }
}

// -------------------- Bracket Generation --------------------
function buildSingleElim(playersIn: Player[]): Match[] {
  const players = [...playersIn];
  const n = players.length;
  const size = nextPowerOfTwo(n);
  while (players.length < size) players.push({ id: `bye-${uid()}`, name: "BYE" });

  const shuffled = shuffle(players);

  const matches: Match[] = [];
  const rounds = Math.log2(size);

  const matchMatrix: Match[][] = [];
  for (let r = 1; r <= rounds; r++) {
    const numMatches = size / Math.pow(2, r);
    const roundMatches: Match[] = new Array(numMatches).fill(null).map(() => ({
      id: `m-${r}-${uid()}`,
      round: r,
      a: null,
      b: null,
      bracket: "W",
    } as Match));
    matchMatrix.push(roundMatches);
  }

  for (let r = 0; r < matchMatrix.length - 1; r++) {
    const cur = matchMatrix[r];
    const nxt = matchMatrix[r + 1];
    cur.forEach((m, i) => {
      const target = nxt[Math.floor(i / 2)];
      m.nextMatchId = target.id;
      m.nextSlot = i % 2 === 0 ? "a" : "b";
    });
  }

  for (let i = 0; i < size; i += 2) {
    const m = matchMatrix[0][i / 2];
    m.a = shuffled[i] || null;
    m.b = shuffled[i + 1] || null;
  }

  matchMatrix.forEach(r => matches.push(...r));
  autoAdvanceByes(matches);
  return matches;
}

function buildDoubleElim(playersIn: Player[]): Match[] {
  // Winners bracket identical to single-elim
  const wb = buildSingleElim(playersIn);
  const byId = new Map(wb.map(m => [m.id, m] as const));

  // Count rounds in WB
  const wbRounds = Math.max(...wb.map(m => m.round));
  const size = Math.pow(2, wbRounds);

  // Build Losers Bracket rounds (simplified chain)
  const losers: Match[] = [];
  const lbRoundsArr: Match[][] = [];
  for (let r = 1; r <= wbRounds - 1; r++) {
    const numMatches = size / Math.pow(2, r + 1); // half of WB round r
    const roundMatches: Match[] = new Array(numMatches).fill(null).map(() => ({
      id: `L-${r}-${uid()}`,
      round: r,
      a: null,
      b: null,
      bracket: "L",
    } as Match));
    lbRoundsArr.push(roundMatches);
  }

  // Link LB winners forward within LB
  for (let r = 0; r < lbRoundsArr.length - 1; r++) {
    const cur = lbRoundsArr[r];
    const nxt = lbRoundsArr[r + 1];
    cur.forEach((m, i) => {
      const target = nxt[Math.floor(i / 2)];
      m.nextMatchId = target.id;
      m.nextSlot = i % 2 === 0 ? "a" : "b";
    });
  }

  // Map WB losers → LB entries (pair WB matches 0&1 → LB r match 0, 2&3 → LB r match 1, etc.)
  for (let r = 1; r <= wbRounds - 1; r++) {
    const wbMatches = wb.filter(m => m.round === r);
    const lbMatches = lbRoundsArr[r - 1];
    wbMatches.forEach((m, i) => {
      const target = lbMatches[Math.floor(i / 2)];
      if (i % 2 === 0) {
        m.loserNextMatchId = target.id;
        m.loserNextSlot = "a";
      } else {
        m.loserNextMatchId = target.id;
        m.loserNextSlot = "b";
      }
    });
  }

  // Grand Final: LB winner vs WB champion
  const gf: Match = {
    id: `GF-${uid()}`,
    round: wbRounds + 1,
    a: null,
    b: null,
    bracket: "GF",
  };

  // Link WB final winner → GF.a
  const wbFinalRound = wb.filter(m => m.round === wbRounds);
  const wbFinal = wbFinalRound[0];
  if (wbFinal) {
    wbFinal.nextMatchId = gf.id;
    wbFinal.nextSlot = "a";
  }

  // Link LB final winner → GF.b
  const lbFinalArr = lbRoundsArr[lbRoundsArr.length - 1] || [];
  const lbFinal = lbFinalArr[0];
  if (lbFinal) {
    lbFinal.nextMatchId = gf.id;
    lbFinal.nextSlot = "b";
  }

  // Flatten LB
  lbRoundsArr.forEach(r => losers.push(...r));

  return [...wb, ...losers, gf];
}

function autoAdvanceByes(matches: Match[]) {
  const byId = new Map(matches.map(m => [m.id, m] as const));
  for (const m of matches) {
    const isABye = m.a?.name === "BYE";
    const isBBye = m.b?.name === "BYE";
    if ((isABye || isBBye) && !(m.winnerId)) {
      const winner = isABye ? m.b : m.a;
      if (winner) {
        m.winnerId = winner.id;
        if (m.nextMatchId && m.nextSlot) {
          const next = byId.get(m.nextMatchId);
          if (next) {
            if (m.nextSlot === "a") next.a = winner;
            else next.b = winner;
          }
        }
      }
    }
  }
}

// -------------------- Winner Poster --------------------
function drawWinnerPoster(canvas: HTMLCanvasElement, tournamentName: string, winnerName: string) {
  const ctx = canvas.getContext("2d");
  if (!ctx) return;
  const W = 1200, H = 675;
  canvas.width = W; canvas.height = H;

  // Background
  const g = ctx.createLinearGradient(0, 0, W, H);
  g.addColorStop(0, "#0f172a");
  g.addColorStop(1, "#1f2937");
  ctx.fillStyle = g; ctx.fillRect(0, 0, W, H);

  // Glow ring
  ctx.beginPath();
  ctx.arc(W/2, H/2, 260, 0, Math.PI*2);
  const g2 = ctx.createRadialGradient(W/2, H/2, 100, W/2, H/2, 300);
  g2.addColorStop(0, "rgba(255,215,0,0.35)");
  g2.addColorStop(1, "rgba(255,215,0,0)");
  ctx.fillStyle = g2; ctx.fill();

  // Text
  ctx.fillStyle = "#fde68a";
  ctx.font = "700 64px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.textAlign = "center";
  ctx.fillText("TOURNAMENT CHAMPION", W/2, 140);

  ctx.fillStyle = "white";
  ctx.font = "800 96px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText(winnerName.toUpperCase(), W/2, H/2 + 20);

  ctx.fillStyle = "#93c5fd";
  ctx.font = "600 40px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText(tournamentName, W/2, H - 80);
}

// -------------------- Component --------------------
export default function FreeTournament() {
  const [opPass, setOpPass] = useState(""); // simple operator gate (free version)
  const [isOperator, setIsOperator] = useState(false);

  const [name, setName] = useState("Action Ladder Smackdown");
  const [format, setFormat] = useState<"single" | "double">("single");
  const [players, setPlayers] = useState<Player[]>(loadLocal("ft_players", []));
  const [pName, setPName] = useState("");
  const [matches, setMatches] = useState<Match[]>(loadLocal("ft_matches", []));
  // Fargo reporting toggle + rows
  const [reportFargo, setReportFargo] = useState<boolean>(loadLocal("ft_report_toggle", false));
  const [reportRows, setReportRows] = useState<ReportRow[]>(loadLocal("ft_report_rows", []));

  const [ocrBusy, setOcrBusy] = useState<string | null>(null); // matchId in progress

  const winner = useMemo(() => {
    if (!matches.length) return null;
    const lastRound = Math.max(...matches.map(m => m.round));
    const finals = matches.filter(m => m.round === lastRound);
    const fm = finals[0];
    if (fm && fm.winnerId) {
      const w = fm.a?.id === fm.winnerId ? fm.a : fm.b?.id === fm.winnerId ? fm.b : null;
      return w || null;
    }
    return null;
  }, [matches]);

  useEffect(() => { saveLocal("ft_players", players); }, [players]);
  useEffect(() => { saveLocal("ft_matches", matches); }, [matches]);
  useEffect(() => { saveLocal("ft_report_toggle", reportFargo); }, [reportFargo]);
  useEffect(() => { saveLocal("ft_report_rows", reportRows); }, [reportRows]);

  // Simple operator pass (front-end only; real apps should use auth)
  function handleOperatorLogin() {
    if (opPass.trim() === "op1234") setIsOperator(true);
    else alert("Wrong operator pass (hint for demo: op1234)");
  }

  function addPlayer() {
    const n = pName.trim();
    if (!n) return;
    if (players.some(p => p.name.toLowerCase() === n.toLowerCase())) {
      alert("Player already added");
      return;
    }
    setPlayers(p => [...p, { id: uid(), name: n }]);
    setPName("");
  }

  function removePlayer(id: string) {
    setPlayers(p => p.filter(x => x.id !== id));
  }

  function randomizeAndBuild() {
    if (players.length < 2) {
      alert("Add at least 2 players");
      return;
    }
    if (format === "single") {
      const m = buildSingleElim(players);
      setMatches(m);
    } else {
      const m = buildDoubleElim(players);
      setMatches(m);
    }
  }
    if (format === "single") {
      const m = buildSingleElim(players);
      setMatches(m);
    } else {
      alert("Double-elimination is coming soon in free mode. Single-elim is ready now.");
    }
  }

  function resetTournament() {
    if (!confirm("Reset bracket and keep players?")) return;
    setMatches([]);
  }

  function clearAll() {
    if (!confirm("Clear players and matches?")) return;
    setPlayers([]);
    setMatches([]);
    setReportRows([]);
  }

  function setWinner(m: Match, winner: "a" | "b") {
    const w = winner === "a" ? m.a : m.b;
    const l = winner === "a" ? m.b : m.a;
    if (!w) return;
    const updated = matches.map(x => ({ ...x }));
    const byId = new Map(updated.map(mm => [mm.id, mm] as const));
    const cur = byId.get(m.id);
    if (!cur) return;

    cur.winnerId = w.id;

    // Winner propagation
    if (cur.nextMatchId && cur.nextSlot) {
      const nxt = byId.get(cur.nextMatchId);
      if (nxt) {
        if (cur.nextSlot === "a") nxt.a = w;
        else nxt.b = w;
      }
    }

    // Double-elim: loser propagation (from Winners bracket only)
    if (format === "double" && cur.bracket === "W" && l) {
      if (cur.loserNextMatchId && cur.loserNextSlot) {
        const lnext = byId.get(cur.loserNextMatchId);
        if (lnext) {
          if (cur.loserNextSlot === "a") lnext.a

    // if reporting is on, append a CSV-ready row
    if (reportFargo && cur.a && cur.b && cur.winnerId) {
      setReportRows(rows => ([
        ...rows,
        {
          tournament: name,
          dateISO: new Date().toISOString(),
          round: cur.round,
          playerA: cur.a?.name || "",
          playerB: cur.b?.name || "",
          scoreA: typeof cur.scoreA === "number" ? cur.scoreA : "",
          scoreB: typeof cur.scoreB === "number" ? cur.scoreB : "",
          winner: cur.winnerId === cur.a.id ? (cur.a?.name || "") : (cur.b?.name || ""),
        }
      ]));
    }
  }

  async function handleOCR(m: Match, file: File) {
    setOcrBusy(m.id);
    const text = await ocrImage(file);

    // Detect simple score like 5-3 or 7–4
    const scoreMatch = text.match(/(\d+)\s*[-–]\s*(\d+)/);
    if (scoreMatch) {
      const a = Number(scoreMatch[1]);
      const b = Number(scoreMatch[2]);
      m.scoreA = a; m.scoreB = b;
    }

    const names = [m.a?.name, m.b?.name].filter(Boolean) as string[];
    const lower = text.toLowerCase();

    let detected: "a" | "b" | null = null;
    if (m.a && lower.includes(m.a.name.toLowerCase())) detected = "a";
    if (m.b && lower.includes(m.b.name.toLowerCase())) detected = detected ? detected : "b";

    if (detected && names.every(n => lower.includes(n.toLowerCase()))) {
      if (/winner:\s*([\w\s]+)/i.test(text)) {
        const [, who] = text.match(/winner:\s*([\w\s]+)/i) || [];
        if (who && m.a && who.toLowerCase().includes(m.a.name.toLowerCase())) detected = "a";
        if (who && m.b && who.toLowerCase().includes(m.b.name.toLowerCase())) detected = "b";
      } else if (/defeats|defeated|beat|winner/i.test(text)) {
        const aOverB = new RegExp(`${m.a?.name}.*(defeats|defeated|beat)`, "i");
        const bOverA = new RegExp(`${m.b?.name}.*(defeats|defeated|beat)`, "i");
        if (aOverB.test(text)) detected = "a";
        if (bOverA.test(text)) detected = "b";
      }
    }

    if (detected) setWinner(m, detected);
    else alert("Couldn't confidently read the photo. Tap a winner manually.");

    setOcrBusy(null);
  }

  // Poster download
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  function downloadPoster() {
    if (!winner || !canvasRef.current) return;
    const link = document.createElement("a");
    link.download = `${winner.name.replace(/\s+/g, "_")}_champion.png`;
    link.href = canvasRef.current.toDataURL("image/png");
    link.click();
  }

  function exportFargoCSV() {
    if (!reportRows.length) {
      alert("No matches to export yet.");
      return;
    }
    const headers = [
      "tournament","dateISO","round","playerA","playerB","scoreA","scoreB","winner"
    ];
    const lines = [headers.join(",")].concat(
      reportRows.map(r => [r.tournament, r.dateISO, r.round, r.playerA, r.playerB, r.scoreA, r.scoreB, r.winner]
        .map(x => typeof x === 'string' ? `"${x.replace(/"/g, '""')}"` : x)
        .join(",")
      )
    );
    const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${name.replace(/\s+/g,'_')}_fargo_report.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  useEffect(() => {
    if (winner && canvasRef.current) {
      drawWinnerPoster(canvasRef.current, name, winner.name);
    }
  }, [winner, name]);

  return (
    <div className="min-h-screen w-full bg-slate-950 text-slate-100 p-4 md:p-8">
      <div className="max-w-7xl mx-auto">
        <header className="mb-6 flex flex-col md:flex-row md:items-end md:justify-between gap-4">
          <div>
            <h1 className="text-3xl md:text-4xl font-black tracking-tight">Tournament Mode (Free)</h1>
            <p className="text-slate-300 mt-1">Random brackets • Photo-to-fill • Operator-run only</p>
          </div>
          <div className="flex items-center gap-2">
            {!isOperator ? (
              <div className="flex gap-2">
                <input
                  value={opPass}
                  onChange={e => setOpPass(e.target.value)}
                  placeholder="Operator pass (demo: op1234)"
                  className="px-3 py-2 rounded-xl bg-slate-800 ring-1 ring-slate-700 focus:outline-none"
                  type="password"
                />
                <button onClick={handleOperatorLogin} className="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold">Unlock</button>
              </div>
            ) : (
              <span className="px-3 py-2 rounded-xl bg-emerald-700/40 ring-1 ring-emerald-600 text-emerald-200">Operator unlocked</span>
            )}
          </div>
        </header>

        {/* Controls */}
        <section className="grid md:grid-cols-3 gap-4">
          <div className="md:col-span-2">
            <div className="p-4 rounded-2xl bg-slate-900 ring-1 ring-slate-800">
              <div className="flex flex-col md:flex-row md:items-center gap-3">
                <input
                  value={name}
                  onChange={e => setName(e.target.value)}
                  className="px-3 py-2 rounded-xl bg-slate-800 ring-1 ring-slate-700 focus:outline-none w-full"
                  placeholder="Tournament name"
                />
                <select
                  value={format}
                  onChange={e => setFormat(e.target.value as any)}
                  className="px-3 py-2 rounded-xl bg-slate-800 ring-1 ring-slate-700"
                >
                  <option value="single">Single Elimination</option>
                  <option value="double">Double Elimination (coming soon)</option>
                </select>
                <label className="flex items-center gap-2 px-3 py-2 rounded-xl bg-slate-800 ring-1 ring-slate-700 select-none">
                  <input type="checkbox" checked={reportFargo} onChange={e => setReportFargo(e.target.checked)} />
                  <span>Report to Fargo (beta)</span>
                </label>
                <button onClick={randomizeAndBuild} className="px-4 py-2 rounded-xl bg-blue-600 hover:bg-blue-500 font-semibold">Randomize & Build</button>
                <button onClick={resetTournament} className="px-4 py-2 rounded-xl bg-slate-700 hover:bg-slate-600">Reset Bracket</button>
                <button onClick={clearAll} className="px-4 py-2 rounded-xl bg-rose-700 hover:bg-rose-600">Clear All</button>
              </div>
            </div>

            {/* Bracket */}
            <BracketView matches={matches} onSetWinner={setWinner} onOCR={handleOCR} ocrBusy={ocrBusy} />
          </div>

          {/* Players */}
          <aside className="p-4 rounded-2xl bg-slate-900 ring-1 ring-slate-800">
            <h2 className="text-xl font-bold mb-3">Players ({players.length})</h2>
            <div className="flex gap-2">
              <input
                value={pName}
                onChange={e => setPName(e.target.value)}
                className="px-3 py-2 rounded-xl bg-slate-800 ring-1 ring-slate-700 w-full"
                placeholder="Add player name"
                disabled={!isOperator}
              />
              <button onClick={addPlayer} disabled={!isOperator} className="px-4 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold disabled:opacity-40">Add</button>
            </div>
            <ul className="mt-3 space-y-2 max-h-[360px] overflow-auto pr-2">
              {players.map(p => (
                <li key={p.id} className="flex items-center justify-between px-3 py-2 rounded-xl bg-slate-800 ring-1 ring-slate-700">
                  <span>{p.name}</span>
                  <button onClick={() => removePlayer(p.id)} disabled={!isOperator} className="px-2 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 disabled:opacity-40">Remove</button>
                </li>
              ))}
            </ul>
            <p className="text-sm text-slate-400 mt-3">Anyone can sign up while the operator is running a tournament. Share this page or add names at the desk.</p>
          </aside>
        </section>

        {/* Winner Poster + Export */}
        {winner && (
          <section className="mt-6 p-4 rounded-2xl bg-slate-900 ring-1 ring-slate-800">
            <div className="flex items-center justify-between mb-3">
              <h2 className="text-xl font-bold">Winner Poster</h2>
              <div className="flex items-center gap-2">
                <button onClick={downloadPoster} className="px-4 py-2 rounded-xl bg-amber-600 hover:bg-amber-500 font-semibold">Download PNG</button>
                <button onClick={exportFargoCSV} disabled={!reportFargo} className="px-4 py-2 rounded-xl bg-blue-600 hover:bg-blue-500 font-semibold disabled:opacity-40">Export Fargo CSV</button>
              </div>
            </div>
            <canvas ref={canvasRef} className="w-full rounded-xl ring-1 ring-slate-700" />
          </section>
        )}

        {/* Footnotes */}
        <footer className="mt-8 text-slate-400 text-sm space-y-1">
          <p>Free Mode limits: single-elimination only; operator pass in frontend; local storage persistence.</p>
          <p>TODO (upgrade path): double-elimination bracket tree; auth for operators; DB persistence; push notifications; Stripe links; direct Fargo API integration.</p>
        </footer>
      </div>
    </div>
  );
}

// -------------------- Bracket View --------------------
function BracketView({ matches, onSetWinner, onOCR, ocrBusy }:{
  matches: Match[];
  onSetWinner: (m: Match, side: "a" | "b") => void;
  onOCR: (m: Match, file: File) => void;
  ocrBusy: string | null;
}) {
  if (!matches.length) {
    return (
      <div className="mt-4 p-6 rounded-2xl bg-slate-900 ring-1 ring-slate-800 text-slate-300">
        Build a bracket to see rounds here. Choose Single Elimination and click <span className="font-semibold">Randomize & Build</span>.
      </div>
    );
  }
  const rounds = Math.max(...matches.map(m => m.round));
  const byRound: Match[][] = Array.from({ length: rounds }, (_, i) => matches.filter(m => m.round === i + 1));

  return (
    <div className="mt-4 overflow-x-auto">
      <div className="min-w-[900px] grid grid-cols-[repeat(var(--cols),1fr)] gap-4" style={{
        // @ts-ignore
        "--cols": rounds,
      }}>
        {byRound.map((roundMatches, idx) => (
          <div key={idx} className="space-y-4">
            <h3 className="text-lg font-bold">Round {idx + 1}</h3>
            {roundMatches.map(m => (
              <MatchCard key={m.id} m={m} onSetWinner={onSetWinner} onOCR={onOCR} busy={ocrBusy === m.id} />
            ))}
          </div>
        ))}
      </div>
    </div>
  );
}

function MatchCard({ m, onSetWinner, onOCR, busy }:{ m: Match; onSetWinner: (m: Match, side: "a" | "b") => void; onOCR: (m: Match, file: File) => void; busy: boolean; }) {
  const aName = m.a?.name || "—";
  const bName = m.b?.name || "—";
  const aWin = m.winnerId && m.a && m.winnerId === m.a.id;
  const bWin = m.winnerId && m.b && m.winnerId === m.b.id;

  return (
    <div className="p-3 rounded-xl bg-slate-800 ring-1 ring-slate-700">
      <div className="text-xs uppercase text-slate-400">Match</div>
      <div className="mt-1 space-y-2">
        <div className="flex items-center gap-2">
          <button
            onClick={() => onSetWinner(m, "a")}
            disabled={!m.a || m.a.name === "BYE"}
            className={`flex-1 text-left px-3 py-2 rounded-lg ring-1 ${aWin ? "ring-emerald-500 bg-emerald-900/30" : "ring-slate-600 bg-slate-900 hover:bg-slate-700"}`}
          >
            {aName}
            {m.a?.name === "BYE" && <span className="ml-2 text-xs text-slate-400">(BYE)</span>}
          </button>
          <input
            type="number"
            inputMode="numeric"
            placeholder="S"
            className="w-12 px-2 py-2 rounded-lg bg-slate-900 ring-1 ring-slate-600 text-center"
            value={m.scoreA ?? ""}
            onChange={(e) => { m.scoreA = e.target.value === "" ? undefined : Number(e.target.value); }}
          />
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={() => onSetWinner(m, "b")}
            disabled={!m.b || m.b.name === "BYE"}
            className={`flex-1 text-left px-3 py-2 rounded-lg ring-1 ${bWin ? "ring-emerald-500 bg-emerald-900/30" : "ring-slate-600 bg-slate-900 hover:bg-slate-700"}`}
          >
            {bName}
            {m.b?.name === "BYE" && <span className="ml-2 text-xs text-slate-400">(BYE)</span>}
          </button>
          <input
            type="number"
            inputMode="numeric"
            placeholder="S"
            className="w-12 px-2 py-2 rounded-lg bg-slate-900 ring-1 ring-slate-600 text-center"
            value={m.scoreB ?? ""}
            onChange={(e) => { m.scoreB = e.target.value === "" ? undefined : Number(e.target.value); }}
          />
        </div>
      </div>
      <div className="mt-3 flex items-center justify-between gap-2">
        <label className="px-3 py-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-sm cursor-pointer">
          <input
            type="file"
            accept="image/*"
            capture="environment"
            className="hidden"
            onChange={(e) => {
              const f = e.target.files?.[0];
              if (f) onOCR(m, f);
              e.currentTarget.value = ""; // reset
            }}
          />
          {busy ? "Reading…" : "Photo → Fill"}
        </label>
        {m.winnerId && <span className="text-emerald-400 text-sm font-semibold">Winner set</span>}
      </div>
    </div>
  );
}
