Visibility + roles (concept)

Keep all objects private in S3.

Use two logical prefixes:

private/{role}/{ownerId}/...

public/{ownerType}/{ownerId}/...

“Public” just means visible to all logged-in users via your API, using short-lived signed GET URLs (still S3-private).

Promotion = copy → delete (move) to the public/ prefix.

If you truly want open, anonymous links (no login), set ACL public-read on “public” objects. I’ll keep it private-by-default below.

1) Minimal auth & roles (JWT example)
// auth.js
import jwt from "jsonwebtoken";

const JWT_SECRET = process.env.JWT_SECRET || "dev_only_change_me";

// Example payload: { sub: "user_123", role: "player" | "operator" | "admin" }
export function requireAuth(req, res, next) {
  try {
    const raw = req.headers.authorization || "";
    const token = raw.startsWith("Bearer ") ? raw.slice(7) : null;
    if (!token) return res.status(401).json({ error: "Missing token" });
    const user = jwt.verify(token, JWT_SECRET);
    req.user = user;
    next();
  } catch {
    res.status(401).json({ error: "Invalid token" });
  }
}

export function requireRole(...roles) {
  return (req, res, next) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Forbidden" });
    }
    next();
  };
}


Wire it in server.js:

import { requireAuth, requireRole } from "./auth.js";
app.use("/api/storage", requireAuth); // protect all storage routes

2) Path helpers
// paths.js
export function privatePrefix(user) {
  // user.role is "player" or "operator"
  return `private/${user.role}/${user.sub}`;
}

export function publicPrefix(userOrOwner) {
  return `public/${userOrOwner.role}/${userOrOwner.sub}`;
}

3) Signed upload now supports privacy + owner folders

Update your /api/storage/sign-upload route:

// server.js (add/replace this route)
app.post("/api/storage/sign-upload", async (req, res) => {
  try {
    const { mime: mimeType, folder = "", visibility = "private" } = req.body || {};
    if (!mimeType || (ALLOWED.size && !ALLOWED.has(mimeType))) {
      return res.status(400).json({ error: "Unsupported file type" });
    }

    const base = visibility === "public" ? publicPrefix(req.user) : privatePrefix(req.user);
    const ext = mime.getExtension(mimeType) || "bin";
    const now = new Date();
    const key = [
      base,
      folder || "uploads",
      now.getFullYear(),
      String(now.getMonth() + 1).padStart(2, "0"),
      String(now.getDate()).padStart(2, "0"),
      `${crypto.randomUUID()}.${ext}`,
    ].join("/");

    const cmd = new PutObjectCommand({
      Bucket: BUCKET,
      Key: key,
      ContentType: mimeType,
      ACL: "private",
    });

    const url = await getSignedUrl(s3, cmd, { expiresIn: 60 });
    res.json({ url, key, expiresIn: 60, maxBytes: MAX_FILE_BYTES });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to sign upload" });
  }
});


Front-end example (send visibility:"private" or "public"):

await fetch("/api/storage/sign-upload", {
  method: "POST",
  headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
  body: JSON.stringify({ mime: file.type, folder: "clips", visibility: "private" })
});

4) List my private files vs global public board
// List current user's private files
app.get("/api/storage/list/private", async (req, res) => {
  try {
    const prefix = privatePrefix(req.user) + "/";
    const resp = await s3.send(new ListObjectsV2Command({ Bucket: BUCKET, Prefix: prefix, MaxKeys: 200 }));
    const items = (resp.Contents || []).map(o => ({ key: o.Key, size: o.Size, lastModified: o.LastModified }));
    res.json({ items });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to list private" });
  }
});

// List ALL public files (any logged-in user can see)
app.get("/api/storage/list/public", async (_req, res) => {
  try {
    const resp = await s3.send(new ListObjectsV2Command({ Bucket: BUCKET, Prefix: "public/", MaxKeys: 200 }));
    const items = (resp.Contents || []).map(o => ({ key: o.Key, size: o.Size, lastModified: o.LastModified }));
    res.json({ items });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to list public" });
  }
});

5) Promote (move) a file: private → public

Only the owner (player or operator) who uploaded the file can promote it. We’ll enforce ownership by checking the key prefix.

import { CopyObjectCommand } from "@aws-sdk/client-s3";

// helper: ensure user owns the key (is under their private prefix)
function assertOwnedPrivateKey(user, key) {
  const expected = privatePrefix(user) + "/";
  return String(key).startsWith(expected);
}

/**
 * Body: { key: "private/player/user_123/uploads/2025/09/11/uuid.mp4" , newFolder?: "clips" }
 */
app.post("/api/storage/promote", async (req, res) => {
  try {
    const { key, newFolder = "shared" } = req.body || {};
    if (!key) return res.status(400).json({ error: "Missing key" });
    if (!assertOwnedPrivateKey(req.user, key)) {
      return res.status(403).json({ error: "Not your file" });
    }

    // build destination under public/
    const pathParts = key.split("/");
    const filename = pathParts[pathParts.length - 1];
    const now = new Date();
    const destKey = [
      publicPrefix(req.user),
      newFolder,
      now.getFullYear(),
      String(now.getMonth() + 1).padStart(2, "0"),
      String(now.getDate()).padStart(2, "0"),
      filename,
    ].join("/");

    // copy then delete (move)
    await s3.send(new CopyObjectCommand({
      Bucket: BUCKET,
      CopySource: `/${BUCKET}/${encodeURIComponent(key).replace(/%2F/g,"/")}`,
      Key: destKey,
      ACL: "private",
    }));
    await s3.send(new DeleteObjectCommand({ Bucket: BUCKET, Key: key }));

    res.json({ ok: true, publicKey: destKey });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to promote" });
  }
});


(If you also want demote public → private, do the same in reverse with CopyObjectCommand.)

6) Signed view URLs respect visibility

Anyone logged in can view any public key; only owners (or admins) can view private keys.

function isPublicKey(key) { return String(key).startsWith("public/"); }

function canView(user, key) {
  if (isPublicKey(key)) return true; // any logged-in user
  return assertOwnedPrivateKey(user, key) || user.role === "admin";
}

app.get("/api/storage/sign-download", async (req, res) => {
  try {
    const { key, download } = req.query;
    if (!key) return res.status(400).json({ error: "Missing key" });
    if (!canView(req.user, String(key))) return res.status(403).json({ error: "Forbidden" });

    const cmd = new GetObjectCommand({
      Bucket: BUCKET,
      Key: String(key),
      ResponseContentDisposition: download ? "attachment" : undefined,
    });
    const url = await getSignedUrl(s3, cmd, { expiresIn: 60 });
    res.json({ url, expiresIn: 60 });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: "Failed to sign download" });
  }
});

7) Front-end UX idea

My Files (Private): shows /api/storage/list/private → allow “Promote” button per row.

Community Board (Public): shows /api/storage/list/public → view/download only (unless admin).

Upload form has toggle Private / Public; default to Private.

8) Optional: truly public (no login)

If you want links anyone can open (no token, no API), after promotion set ACL: "public-read" (and optionally use a CDN domain). Replace in the CopyObjectCommand:

await s3.send(new CopyObjectCommand({
  Bucket: BUCKET,
  CopySource: `/${BUCKET}/${encodeURIComponent(key).replace(/%2F/g,"/")}`,
  Key: destKey,
  ACL: "public-read", // <— anonymous readable
}));