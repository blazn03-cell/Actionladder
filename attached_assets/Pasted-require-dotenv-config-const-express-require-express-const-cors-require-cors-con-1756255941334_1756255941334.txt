require("dotenv").config();
const express = require("express");
const cors = require("cors");
const Stripe = require("stripe");
const bodyParser = require("body-parser");

const app = express();
app.set("trust proxy", 1);
app.use(cors({ origin: true }));
app.use("/api", express.json()); // JSON for normal API routes

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2024-06-20",
});

/** ---------------------------
 *  REPLACE THESE with your DB
 *  --------------------------- */
async function setMembership(userId, tier, status, currentPeriodEnd, ids = {}) {
  // TODO: write to your DB (users table)
  // e.g. role=tier, membership_status=status, stripe_customer_id, subscription_id, period_end
  console.log("DB UPDATE ->", { userId, tier, status, currentPeriodEnd, ids });
}
async function getStripeCustomerIdForUser(userId) {
  // Optional: if you store customer_id, return it here.
  return null;
}

/** Create Checkout Session (subscription) */
app.post("/api/checkout/create-session", async (req, res) => {
  try {
    const { tier = "basic", userId, email } = req.body || {};
    if (!userId) return res.status(400).json({ error: "userId required" });

    const priceId =
      tier === "pro" ? process.env.PRO_PRICE_ID : process.env.BASIC_PRICE_ID;

    // If you already have a Stripe customer_id for this user, pass `customer: id`
    const existingCustomer = await getStripeCustomerIdForUser(userId);

    const session = await stripe.checkout.sessions.create({
      mode: "subscription",
      allow_promotion_codes: true,
      billing_address_collection: "auto",
      ...(existingCustomer
        ? { customer: existingCustomer }
        : { customer_email: email }),
      line_items: [{ price: priceId, quantity: 1 }],
      success_url: `${process.env.APP_URL}/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.APP_URL}/cancel`,
      client_reference_id: userId,
      subscription_data: {
        metadata: { userId, tier },
        // trials/coupons can go here later
      },
      metadata: { userId, tier },
      automatic_tax: { enabled: false }, // turn on later if you use Stripe Tax
    });

    res.json({ url: session.url });
  } catch (e) {
    console.error(e);
    res.status(400).json({ error: e.message });
  }
});

/** Customer Portal – lets users update card/cancel/upgrade themselves */
app.post("/api/billing/portal", async (req, res) => {
  try {
    const { customerId } = req.body || {};
    if (!customerId) return res.status(400).json({ error: "customerId required" });

    const session = await stripe.billingPortal.sessions.create({
      customer: customerId,
      return_url: `${process.env.APP_URL}/account`,
    });
    res.json({ url: session.url });
  } catch (e) {
    console.error(e);
    res.status(400).json({ error: e.message });
  }
});

/** Webhook MUST use raw body (no JSON parser) */
app.post(
  "/api/stripe/webhook",
  bodyParser.raw({ type: "application/json" }),
  async (req, res) => {
    const sig = req.headers["stripe-signature"];
    let event;

    try {
      event = stripe.webhooks.constructEvent(
        req.body,
        sig,
        process.env.STRIPE_WEBHOOK_SECRET
      );
    } catch (err) {
      console.error("⚠️  Webhook signature verification failed.", err.message);
      return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    try {
      switch (event.type) {
        case "checkout.session.completed": {
          const sess = event.data.object;
          const userId =
            sess.client_reference_id || (sess.metadata && sess.metadata.userId);
          const tier = (sess.metadata && sess.metadata.tier) || "basic";
          const subscriptionId = sess.subscription || undefined;
          await setMembership(userId, tier, "active", undefined, {
            customer: sess.customer,
            sub: subscriptionId,
          });
          break;
        }
        case "customer.subscription.created":
        case "customer.subscription.updated": {
          const sub = event.data.object;
          const status = sub.status; // active | trialing | past_due | canceled | unpaid | ...
          const userId =
            (sub.metadata && sub.metadata.userId) || null;
          // infer tier from metadata or price nickname
          let tier = "basic";
          if (sub.metadata && sub.metadata.tier) tier = sub.metadata.tier;
          else if (
            sub.items.data[0]?.price?.nickname &&
            sub.items.data[0].price.nickname.toLowerCase().includes("pro")
          )
            tier = "pro";

          if (userId) {
            await setMembership(userId, tier, status, sub.current_period_end, {
              customer: sub.customer,
              sub: sub.id,
            });
          }
          break;
        }
        case "customer.subscription.deleted": {
          const sub = event.data.object;
          const userId = sub.metadata && sub.metadata.userId;
          if (userId) {
            await setMembership(userId, "basic", "canceled", sub.current_period_end, {
              sub: sub.id,
            });
          }
          break;
        }
        case "invoice.payment_failed": {
          const inv = event.data.object;
          const userId = inv.metadata && inv.metadata.userId;
          if (userId) await setMembership(userId, "basic", "past_due");
          break;
        }
        default:
          // ignore other events
          break;
      }

      res.json({ received: true });
    } catch (e) {
      console.error("Webhook handler error:", e);
      res.status(500).send("Webhook failure");
    }
  }
);

// Simple success/cancel routes for testing
app.get("/success", (req, res) =>
  res.send("Payment success – you can close this tab.")
);
app.get("/cancel", (req, res) => res.send("Payment canceled.")
);

const port = process.env.PORT || 3000;
app.listen(port, () => console.log(`Server listening on ${port}`));
