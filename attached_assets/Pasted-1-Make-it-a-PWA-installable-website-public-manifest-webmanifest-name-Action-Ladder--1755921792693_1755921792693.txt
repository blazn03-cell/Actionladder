1) Make it a PWA (installable website)
/public/manifest.webmanifest
{
  "name": "Action Ladder",
  "short_name": "ActionLadder",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#0f172a",
  "theme_color": "#0ea5e9",
  "description": "Action Ladder — pool. points. pride. payouts.",
  "icons": [
    { "src": "/icons/icon-192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "/icons/icon-512.png", "sizes": "512x512", "type": "image/png" },
    { "src": "/icons/maskable-512.png", "sizes": "512x512", "type": "image/png", "purpose": "maskable" }
  ]
}


Put PNGs at /public/icons/ (192, 512, and a maskable 512).

/public/sw.js (very light Workbox-free SW)
const CACHE = "actionladder-v1";
const OFFLINE_URL = "/offline.html";

self.addEventListener("install", (e) => {
  e.waitUntil((async () => {
    const cache = await caches.open(CACHE);
    await cache.addAll(["/", OFFLINE_URL, "/manifest.webmanifest"]);
  })());
  self.skipWaiting();
});

self.addEventListener("activate", (e) => {
  e.waitUntil(self.clients.claim());
});

self.addEventListener("fetch", (e) => {
  const { request } = e;
  if (request.method !== "GET") return;

  e.respondWith((async () => {
    try {
      const net = await fetch(request);
      const cache = await caches.open(CACHE);
      cache.put(request, net.clone());
      return net;
    } catch {
      const cache = await caches.open(CACHE);
      const cached = await cache.match(request);
      return cached || cache.match(OFFLINE_URL);
    }
  })());
});

/public/offline.html
<!doctype html>
<html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width">
<title>Offline • Action Ladder</title>
<style>body{font-family:system-ui;margin:2rem;}</style>
</head><body>
<h1>Offline</h1>
<p>You’re offline. Your schedule, ledger, and proposals will sync when you’re back.</p>
</body></html>

Register the service worker (React/Next, put once on the client)

If you have a root App or Layout file, add:

useEffect(() => {
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.register("/sw.js").catch(()=>{});
  }
}, []);

Add tags to your HTML head (PWA hints)

Link the manifest: <link rel="manifest" href="/manifest.webmanifest">

Add theme color: <meta name="theme-color" content="#0ea5e9">

iOS standalone:

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="/icons/icon-192.png">


Result: Users can Install on desktop/mobile, get an app-like icon, and work offline for core screens.

2) Wrap it as native apps (Capacitor)
Install Capacitor
npm i @capacitor/core @capacitor/cli
# add platforms
npm i @capacitor/android @capacitor/ios

capacitor.config.ts (at project root)
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.actionladder.app',
  appName: 'Action Ladder',
  webDir: 'dist', // or ".next/out" or "build" depending on your bundler
  bundledWebRuntime: false,
  server: {
    // For prod, leave this commented so it loads from local bundle.
    // url: "https://your-production-domain.com", cleartext: false
  },
  android: {
    allowMixedContent: false
  }
};
export default config;


Make sure your web build outputs to dist (or update webDir accordingly).

Build & add platforms
npm run build           # creates the webDir bundle
npx cap init            # if not already initialized
npx cap add android
npx cap add ios
npx cap copy
npx cap open android    # opens Android Studio
npx cap open ios        # opens Xcode


Ship test builds from Android Studio/Xcode.

3) Push notifications (nice-to-have, both web + native)

PWA Web Push: Use VAPID + your SW. A hosted service like OneSignal or Firebase (FCM for Web) makes it simple.

Native: For Android, FCM; for iOS, APNs (OneSignal or Firebase Cloud Messaging with an APNs key).

Use them for match reminders (48/12h), proposal accepted, payout posted, Hustle Night.

(If you want, I can give you a ready-to-paste OneSignal init + SW hook next.)

4) Deep links & tenant routing

Keep /t/{slug} routing in web.

Native deep links:

Android: add <intent-filter> with <data android:host="yourdomain.com" android:pathPrefix="/t/" />

iOS: enable Associated Domains: applinks:yourdomain.com and host apple-app-site-association.

Users tapping https://yourdomain.com/t/seguin can open inside the app.