Action Ladder — Db/stripe Seed Kit (postgres + Stripe)
Action Ladder — DB/Stripe Seed Kit (Postgres + Stripe)

Below is a complete, ready‑to‑paste setup for:

DB choice: Neon Postgres (works with any Postgres)

Core schema (minimal yet expandable)

Stripe product catalog structure with metadata.domain_type

One‑shot Node script to seed Stripe Products/Prices + demo Customers

SQL seed for demo users/halls

.env example and notes

1) Decision

DB: Postgres (Neon recommended)

Reason: Strong relational model for halls↔operators↔players, transactions, payouts, auditability, easy hosted serverless via Neon.

2) Minimal Core Schema (Postgres)

Focused on just what the seed and early flows need. You can expand later (tournaments, streaks, gifts/fans events, etc.).

-- 01_users.sql
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  full_name TEXT NOT NULL,
  role TEXT NOT NULL CHECK (role IN ('player','operator','trustee','owner','admin')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  stripe_customer_id TEXT,
  CONSTRAINT email_chk CHECK (position('@' in email) > 1)
);


-- 02_halls.sql
CREATE TABLE IF NOT EXISTS halls (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  city TEXT,
  state TEXT,
  table_mix JSONB, -- {"nine_ft":2, "eight_ft":4, "barbox":6}
  owner_user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);


-- 03_user_hall_roles.sql
CREATE TABLE IF NOT EXISTS user_hall_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  hall_id UUID NOT NULL REFERENCES halls(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('operator','player','trustee')),
  UNIQUE(user_id, hall_id, role)
);


-- 04_products_shadow.sql
-- Optional shadow tables to mirror Stripe for quick lookups
CREATE TABLE IF NOT EXISTS stripe_products (
  id TEXT PRIMARY KEY,          -- stripe product id
  name TEXT NOT NULL,
  domain_type TEXT NOT NULL,    -- player_membership | operator_subscription | addon
  tier TEXT,                    -- rookie | standard | premium | small | medium | large | mega
  visibility TEXT,              -- player | operator | private
  raw JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);


CREATE TABLE IF NOT EXISTS stripe_prices (
  id TEXT PRIMARY KEY,          -- stripe price id
  product_id TEXT NOT NULL REFERENCES stripe_products(id) ON DELETE CASCADE,
  currency TEXT NOT NULL,
  unit_amount INTEGER,          -- cents
  interval TEXT,                -- month | year | week | one_time
  trial_days INTEGER,
  raw JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);


-- 05_subscriptions.sql (IDs stored only; actual billing in Stripe)
CREATE TABLE IF NOT EXISTS subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  hall_id UUID REFERENCES halls(id) ON DELETE SET NULL,
  stripe_subscription_id TEXT UNIQUE,
  stripe_price_id TEXT REFERENCES stripe_prices(id),
  status TEXT NOT NULL DEFAULT 'created',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()

Extensions (optional):

CREATE EXTENSION IF NOT EXISTS pgcrypto; -- for gen_random_uuid on Neon
3) Stripe Product Catalog Structure

We’ll create three domains using product.metadata.domain_type:

player_membership — player‑visible plans (cheaper than typical leagues)

operator_subscription — private to player UI (only operator/owner/trustees see revenue details)

addon — optional modules (e.g., Tournaments, Gifts & Fans, Analytics)

Common metadata keys we’ll store on Product:

domain_type: player_membership | operator_subscription | addon

tier: e.g., rookie|standard|premium or small|medium|large|mega

visibility: player | operator | private

weekly_dues: e.g., 800 (=$8) if we ever surface weekly comparison

intro_fee: e.g., 0 to beat league first‑month cost

match_fee_pct: e.g., 5 (platform share on challenge fees if applicable)

hall_limit: for operator tiers (e.g., 1/3/6/12 halls)

features_json: JSON string of feature flags (for UI)

Prices will use recurring intervals:

Players → monthly plans (no big upfront hit; win vs leagues)

Operators → monthly or annual

Add‑ons → monthly (can also do one‑time event fees)

Player Memberships (example pricing)

Rookie — $39/month (beats leagues; minimal perks)

Standard — $59/month (balanced perks)

Premium — $79/month (max perks, priority events)

Operator Subscriptions (private)

Small — $149/month (up to 1 hall)

Medium — $299/month (up to 3 halls)

Large — $499/month (up to 6 halls)

Mega — $899/month (12 halls, white‑label, analytics)

Add‑ons

Tournament Module — $49/month

Gifts & Fans — $19/month

Analytics Pro — $39/month

You can tweak numbers as we finalize the revenue story.

4) One‑Shot Seed Script (Node, Stripe + Postgres)

File: seed_stripe_and_db.ts (works with ts-node or transpile with tsc)

// seed_stripe_and_db.ts
// Usage: ts-node seed_stripe_and_db.ts  (or node after tsc)


import 'dotenv/config';
import Stripe from 'stripe';
import { Client } from 'pg';


const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-06-20',
});


const pg = new Client({ connectionString: process.env.DATABASE_URL });


async function upsertProduct(p: Stripe.ProductCreateParams) {
  // Idempotent: search by name + domain_type
  const existing = await stripe.products.search({
    query: `name:'${p.name.replace(/'/g, "\\'")}' AND metadata['domain_type']:'${p.metadata?.domain_type}'`,
    limit: 1,
  });
  if (existing.data[0]) return existing.data[0];
  return await stripe.products.create(p);
}


async function upsertPrice(productId: string, price: { unit_amount: number; interval: 'month' | 'year' | 'week' | 'one_time' }) {
  // Idempotent-ish: search by product + amount + interval
  const existing = await stripe.prices.search({
    query: `product:'${productId}' AND active:'true' AND unit_amount:'${price.unit_amount}' AND recurring.interval:'${price.interval}'`,
    limit: 1,
  });
  if (existing.data[0]) return existing.data[0];
  return await stripe.prices.create({
    product: productId,
    currency: 'usd',
    unit_amount: price.unit_amount,
    recurring: price.interval === 'one_time' ? undefined : { interval: price.interval },
  });
}


async function mirrorProductToDB(prod: Stripe.Product) {
  await pg.query(
    `INSERT INTO stripe_products (id, name, domain_type, tier, visibility, raw)
     VALUES ($1,$2,$3,$4,$5,$6)
     ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name, raw = EXCLUDED.raw`,
    [prod.id, prod.name, prod.metadata['domain_type'], prod.metadata['tier'] || null, prod.metadata['visibility'] || null, prod as any]
  );
}


async function mirrorPriceToDB(price: Stripe.Price) {
  await pg.query(
    `INSERT INTO stripe_prices (id, product_id, currency, unit_amount, interval, trial_days, raw)
     VALUES ($1,$2,$3,$4,$5,$6,$7)
     ON CONFLICT (id) DO UPDATE SET unit_amount = EXCLUDED.unit_amount, raw = EXCLUDED.raw`,
    [
      price.id,
      typeof price.product === 'string' ? price.product : price.product.id,
      price.currency,
      price.unit_amount || null,
      (price.type === 'recurring' ? price.recurring?.interval : 'one_time') || null,
      price.recurring?.trial_period_days || null,
      price as any,

Install deps

npm i stripe pg dotenv
# if using TypeScript
npm i -D typescript ts-node @types/node
npx tsc --init
5) SQL Demo Seed (optional standalone)
-- seed_demo.sql
INSERT INTO users (email, full_name, role) VALUES
  ('player.rookie@example.com','Rookie Ray','player') ON CONFLICT DO NOTHING,
  ('player.standard@example.com','Standard Sam','player') ON CONFLICT DO NOTHING,
  ('player.premium@example.com','Premium Pam','player') ON CONFLICT DO NOTHING,
  ('op.small@example.com','Op Small Sally','operator') ON CONFLICT DO NOTHING,
  ('op.medium@example.com','Op Medium Mike','operator') ON CONFLICT DO NOTHING;


INSERT INTO halls (name, city, state, table_mix)
VALUES
  ('The Spot — Seguin','Seguin','TX','{"nine_ft":2,"eight_ft":2,"barbox":6}'),
  ('Tri‑City Hub — New Braunfels','New Braunfels','TX','{"nine_ft":3,"eight_ft":4,"barbox":4}')
ON CONFLICT DO NOTHING;
6) .env Example
# Stripe Test Secret Key
STRIPE_SECRET_KEY=sk_test_XXXXXXXXXXXXXXXXXXXXXXXX
# Neon/Postgres
DATABASE_URL=postgresql://user:pass@ep-xxx-yy-zz.neon.tech/main?sslmode=require
# For your webhook server later
STRIPE_WEBHOOK_SECRET=whsec_XXXXXXXXXXXXXXXXXXXX

Note: Run the seed only in Stripe Test Mode. When ready for live, switch keys and re‑seed with production prices.

7) Mapping Notes (Backend)

Use product.metadata.domain_type to route UI/permissions:

player_membership → exposed on Player signup flows.

operator_subscription / addon → hidden from players; visible to operators/admins.

Shadow stripe_products/prices tables let your app quickly map price IDs → features, without a round‑trip to Stripe every time.

When you add the Gifts & Fans module in‑app, gate features off addon subscriptions.